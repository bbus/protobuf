// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/protobuf/unittest_proto3.proto
namespace ProtobufUnittest

open Google.Protobuf
open Google.Protobuf.Reflection
open Google.Protobuf.Collections

type UnittestProto3Reflection() =
  static let descriptor =
    let descriptorData =
      System.Convert.FromBase64String(
          System.String.Concat(
              "CiVnb29nbGUvcHJvdG9idWYvdW5pdHRlc3RfcHJvdG8zLnByb3RvEhFwcm90",
              "b2J1Zl91bml0dGVzdBosZ29vZ2xlL3Byb3RvYnVmL3VuaXR0ZXN0X2ltcG9y",
              "dF9wcm90bzMucHJvdG8i8A8KDFRlc3RBbGxUeXBlcxIUCgxzaW5nbGVfaW50",
              "MzIYASABKAUSFAoMc2luZ2xlX2ludDY0GAIgASgDEhUKDXNpbmdsZV91aW50",
              "MzIYAyABKA0SFQoNc2luZ2xlX3VpbnQ2NBgEIAEoBBIVCg1zaW5nbGVfc2lu",
              "dDMyGAUgASgREhUKDXNpbmdsZV9zaW50NjQYBiABKBISFgoOc2luZ2xlX2Zp",
              "eGVkMzIYByABKAcSFgoOc2luZ2xlX2ZpeGVkNjQYCCABKAYSFwoPc2luZ2xl",
              "X3NmaXhlZDMyGAkgASgPEhcKD3NpbmdsZV9zZml4ZWQ2NBgKIAEoEBIUCgxz",
              "aW5nbGVfZmxvYXQYCyABKAISFQoNc2luZ2xlX2RvdWJsZRgMIAEoARITCgtz",
              "aW5nbGVfYm9vbBgNIAEoCBIVCg1zaW5nbGVfc3RyaW5nGA4gASgJEhQKDHNp",
              "bmdsZV9ieXRlcxgPIAEoDBJMChVzaW5nbGVfbmVzdGVkX21lc3NhZ2UYEiAB",
              "KAsyLS5wcm90b2J1Zl91bml0dGVzdC5UZXN0QWxsVHlwZXMuTmVzdGVkTWVz",
              "c2FnZRJBChZzaW5nbGVfZm9yZWlnbl9tZXNzYWdlGBMgASgLMiEucHJvdG9i",
              "dWZfdW5pdHRlc3QuRm9yZWlnbk1lc3NhZ2USRgoVc2luZ2xlX2ltcG9ydF9t",
              "ZXNzYWdlGBQgASgLMicucHJvdG9idWZfdW5pdHRlc3RfaW1wb3J0LkltcG9y",
              "dE1lc3NhZ2USRgoSc2luZ2xlX25lc3RlZF9lbnVtGBUgASgOMioucHJvdG9i",
              "dWZfdW5pdHRlc3QuVGVzdEFsbFR5cGVzLk5lc3RlZEVudW0SOwoTc2luZ2xl",
              "X2ZvcmVpZ25fZW51bRgWIAEoDjIeLnByb3RvYnVmX3VuaXR0ZXN0LkZvcmVp",
              "Z25FbnVtEkAKEnNpbmdsZV9pbXBvcnRfZW51bRgXIAEoDjIkLnByb3RvYnVm",
              "X3VuaXR0ZXN0X2ltcG9ydC5JbXBvcnRFbnVtElMKHHNpbmdsZV9wdWJsaWNf",
              "aW1wb3J0X21lc3NhZ2UYGiABKAsyLS5wcm90b2J1Zl91bml0dGVzdF9pbXBv",
              "cnQuUHVibGljSW1wb3J0TWVzc2FnZRIWCg5yZXBlYXRlZF9pbnQzMhgfIAMo",
              "BRIWCg5yZXBlYXRlZF9pbnQ2NBggIAMoAxIXCg9yZXBlYXRlZF91aW50MzIY",
              "ISADKA0SFwoPcmVwZWF0ZWRfdWludDY0GCIgAygEEhcKD3JlcGVhdGVkX3Np",
              "bnQzMhgjIAMoERIXCg9yZXBlYXRlZF9zaW50NjQYJCADKBISGAoQcmVwZWF0",
              "ZWRfZml4ZWQzMhglIAMoBxIYChByZXBlYXRlZF9maXhlZDY0GCYgAygGEhkK",
              "EXJlcGVhdGVkX3NmaXhlZDMyGCcgAygPEhkKEXJlcGVhdGVkX3NmaXhlZDY0",
              "GCggAygQEhYKDnJlcGVhdGVkX2Zsb2F0GCkgAygCEhcKD3JlcGVhdGVkX2Rv",
              "dWJsZRgqIAMoARIVCg1yZXBlYXRlZF9ib29sGCsgAygIEhcKD3JlcGVhdGVk",
              "X3N0cmluZxgsIAMoCRIWCg5yZXBlYXRlZF9ieXRlcxgtIAMoDBJOChdyZXBl",
              "YXRlZF9uZXN0ZWRfbWVzc2FnZRgwIAMoCzItLnByb3RvYnVmX3VuaXR0ZXN0",
              "LlRlc3RBbGxUeXBlcy5OZXN0ZWRNZXNzYWdlEkMKGHJlcGVhdGVkX2ZvcmVp",
              "Z25fbWVzc2FnZRgxIAMoCzIhLnByb3RvYnVmX3VuaXR0ZXN0LkZvcmVpZ25N",
              "ZXNzYWdlEkgKF3JlcGVhdGVkX2ltcG9ydF9tZXNzYWdlGDIgAygLMicucHJv",
              "dG9idWZfdW5pdHRlc3RfaW1wb3J0LkltcG9ydE1lc3NhZ2USSAoUcmVwZWF0",
              "ZWRfbmVzdGVkX2VudW0YMyADKA4yKi5wcm90b2J1Zl91bml0dGVzdC5UZXN0",
              "QWxsVHlwZXMuTmVzdGVkRW51bRI9ChVyZXBlYXRlZF9mb3JlaWduX2VudW0Y",
              "NCADKA4yHi5wcm90b2J1Zl91bml0dGVzdC5Gb3JlaWduRW51bRJCChRyZXBl",
              "YXRlZF9pbXBvcnRfZW51bRg1IAMoDjIkLnByb3RvYnVmX3VuaXR0ZXN0X2lt",
              "cG9ydC5JbXBvcnRFbnVtElUKHnJlcGVhdGVkX3B1YmxpY19pbXBvcnRfbWVz",
              "c2FnZRg2IAMoCzItLnByb3RvYnVmX3VuaXR0ZXN0X2ltcG9ydC5QdWJsaWNJ",
              "bXBvcnRNZXNzYWdlEhYKDG9uZW9mX3VpbnQzMhhvIAEoDUgAEk0KFG9uZW9m",
              "X25lc3RlZF9tZXNzYWdlGHAgASgLMi0ucHJvdG9idWZfdW5pdHRlc3QuVGVz",
              "dEFsbFR5cGVzLk5lc3RlZE1lc3NhZ2VIABIWCgxvbmVvZl9zdHJpbmcYcSAB",
              "KAlIABIVCgtvbmVvZl9ieXRlcxhyIAEoDEgAGhsKDU5lc3RlZE1lc3NhZ2US",
              "CgoCYmIYASABKAUiVgoKTmVzdGVkRW51bRIbChdORVNURURfRU5VTV9VTlNQ",
              "RUNJRklFRBAAEgcKA0ZPTxABEgcKA0JBUhACEgcKA0JBWhADEhAKA05FRxD/",
              "//////////8BQg0KC29uZW9mX2ZpZWxkIrsBChJOZXN0ZWRUZXN0QWxsVHlw",
              "ZXMSNAoFY2hpbGQYASABKAsyJS5wcm90b2J1Zl91bml0dGVzdC5OZXN0ZWRU",
              "ZXN0QWxsVHlwZXMSMAoHcGF5bG9hZBgCIAEoCzIfLnByb3RvYnVmX3VuaXR0",
              "ZXN0LlRlc3RBbGxUeXBlcxI9Cg5yZXBlYXRlZF9jaGlsZBgDIAMoCzIlLnBy",
              "b3RvYnVmX3VuaXR0ZXN0Lk5lc3RlZFRlc3RBbGxUeXBlcyI0ChRUZXN0RGVw",
              "cmVjYXRlZEZpZWxkcxIcChBkZXByZWNhdGVkX2ludDMyGAEgASgFQgIYASIb",
              "Cg5Gb3JlaWduTWVzc2FnZRIJCgFjGAEgASgFIjAKElRlc3RSZXNlcnZlZEZp",
              "ZWxkc0oECAIQA0oECA8QEEoECAkQDFIDYmFyUgNiYXoiWgoRVGVzdEZvcmVp",
              "Z25OZXN0ZWQSRQoOZm9yZWlnbl9uZXN0ZWQYASABKAsyLS5wcm90b2J1Zl91",
              "bml0dGVzdC5UZXN0QWxsVHlwZXMuTmVzdGVkTWVzc2FnZSI0ChhUZXN0UmVh",
              "bGx5TGFyZ2VUYWdOdW1iZXISCQoBYRgBIAEoBRINCgJiYhj///9/IAEoBSJV",
              "ChRUZXN0UmVjdXJzaXZlTWVzc2FnZRIyCgFhGAEgASgLMicucHJvdG9idWZf",
              "dW5pdHRlc3QuVGVzdFJlY3Vyc2l2ZU1lc3NhZ2USCQoBaRgCIAEoBSJLChRU",
              "ZXN0TXV0dWFsUmVjdXJzaW9uQRIzCgJiYhgBIAEoCzInLnByb3RvYnVmX3Vu",
              "aXR0ZXN0LlRlc3RNdXR1YWxSZWN1cnNpb25CImIKFFRlc3RNdXR1YWxSZWN1",
              "cnNpb25CEjIKAWEYASABKAsyJy5wcm90b2J1Zl91bml0dGVzdC5UZXN0TXV0",
              "dWFsUmVjdXJzaW9uQRIWCg5vcHRpb25hbF9pbnQzMhgCIAEoBSJMChJUZXN0",
              "RW51bUFsbG93QWxpYXMSNgoFdmFsdWUYASABKA4yJy5wcm90b2J1Zl91bml0",
              "dGVzdC5UZXN0RW51bVdpdGhEdXBWYWx1ZSLrAgoXVGVzdENhbWVsQ2FzZUZp",
              "ZWxkTmFtZXMSFgoOUHJpbWl0aXZlRmllbGQYASABKAUSEwoLU3RyaW5nRmll",
              "bGQYAiABKAkSMQoJRW51bUZpZWxkGAMgASgOMh4ucHJvdG9idWZfdW5pdHRl",
              "c3QuRm9yZWlnbkVudW0SNwoMTWVzc2FnZUZpZWxkGAQgASgLMiEucHJvdG9i",
              "dWZfdW5pdHRlc3QuRm9yZWlnbk1lc3NhZ2USHgoWUmVwZWF0ZWRQcmltaXRp",
              "dmVGaWVsZBgHIAMoBRIbChNSZXBlYXRlZFN0cmluZ0ZpZWxkGAggAygJEjkK",
              "EVJlcGVhdGVkRW51bUZpZWxkGAkgAygOMh4ucHJvdG9idWZfdW5pdHRlc3Qu",
              "Rm9yZWlnbkVudW0SPwoUUmVwZWF0ZWRNZXNzYWdlRmllbGQYCiADKAsyIS5w",
              "cm90b2J1Zl91bml0dGVzdC5Gb3JlaWduTWVzc2FnZSLHAQoSVGVzdEZpZWxk",
              "T3JkZXJpbmdzEhEKCW15X3N0cmluZxgLIAEoCRIOCgZteV9pbnQYASABKAMS",
              "EAoIbXlfZmxvYXQYZSABKAISUwoVc2luZ2xlX25lc3RlZF9tZXNzYWdlGMgB",
              "IAEoCzIzLnByb3RvYnVmX3VuaXR0ZXN0LlRlc3RGaWVsZE9yZGVyaW5ncy5O",
              "ZXN0ZWRNZXNzYWdlGicKDU5lc3RlZE1lc3NhZ2USCgoCb28YAiABKAMSCgoC",
              "YmIYASABKAUiSwoRU3BhcnNlRW51bU1lc3NhZ2USNgoLc3BhcnNlX2VudW0Y",
              "ASABKA4yIS5wcm90b2J1Zl91bml0dGVzdC5UZXN0U3BhcnNlRW51bSIZCglP",
              "bmVTdHJpbmcSDAoEZGF0YRgBIAEoCSIaCgpNb3JlU3RyaW5nEgwKBGRhdGEY",
              "ASADKAkiGAoIT25lQnl0ZXMSDAoEZGF0YRgBIAEoDCIZCglNb3JlQnl0ZXMS",
              "DAoEZGF0YRgBIAEoDCIcCgxJbnQzMk1lc3NhZ2USDAoEZGF0YRgBIAEoBSId",
              "Cg1VaW50MzJNZXNzYWdlEgwKBGRhdGEYASABKA0iHAoMSW50NjRNZXNzYWdl",
              "EgwKBGRhdGEYASABKAMiHQoNVWludDY0TWVzc2FnZRIMCgRkYXRhGAEgASgE",
              "IhsKC0Jvb2xNZXNzYWdlEgwKBGRhdGEYASABKAgicwoJVGVzdE9uZW9mEhEK",
              "B2Zvb19pbnQYASABKAVIABIUCgpmb29fc3RyaW5nGAIgASgJSAASNgoLZm9v",
              "X21lc3NhZ2UYAyABKAsyHy5wcm90b2J1Zl91bml0dGVzdC5UZXN0QWxsVHlw",
              "ZXNIAEIFCgNmb28iqgMKD1Rlc3RQYWNrZWRUeXBlcxIYCgxwYWNrZWRfaW50",
              "MzIYWiADKAVCAhABEhgKDHBhY2tlZF9pbnQ2NBhbIAMoA0ICEAESGQoNcGFj",
              "a2VkX3VpbnQzMhhcIAMoDUICEAESGQoNcGFja2VkX3VpbnQ2NBhdIAMoBEIC",
              "EAESGQoNcGFja2VkX3NpbnQzMhheIAMoEUICEAESGQoNcGFja2VkX3NpbnQ2",
              "NBhfIAMoEkICEAESGgoOcGFja2VkX2ZpeGVkMzIYYCADKAdCAhABEhoKDnBh",
              "Y2tlZF9maXhlZDY0GGEgAygGQgIQARIbCg9wYWNrZWRfc2ZpeGVkMzIYYiAD",
              "KA9CAhABEhsKD3BhY2tlZF9zZml4ZWQ2NBhjIAMoEEICEAESGAoMcGFja2Vk",
              "X2Zsb2F0GGQgAygCQgIQARIZCg1wYWNrZWRfZG91YmxlGGUgAygBQgIQARIX",
              "CgtwYWNrZWRfYm9vbBhmIAMoCEICEAESNwoLcGFja2VkX2VudW0YZyADKA4y",
              "Hi5wcm90b2J1Zl91bml0dGVzdC5Gb3JlaWduRW51bUICEAEiyAMKEVRlc3RV",
              "bnBhY2tlZFR5cGVzEhoKDnVucGFja2VkX2ludDMyGFogAygFQgIQABIaCg51",
              "bnBhY2tlZF9pbnQ2NBhbIAMoA0ICEAASGwoPdW5wYWNrZWRfdWludDMyGFwg",
              "AygNQgIQABIbCg91bnBhY2tlZF91aW50NjQYXSADKARCAhAAEhsKD3VucGFj",
              "a2VkX3NpbnQzMhheIAMoEUICEAASGwoPdW5wYWNrZWRfc2ludDY0GF8gAygS",
              "QgIQABIcChB1bnBhY2tlZF9maXhlZDMyGGAgAygHQgIQABIcChB1bnBhY2tl",
              "ZF9maXhlZDY0GGEgAygGQgIQABIdChF1bnBhY2tlZF9zZml4ZWQzMhhiIAMo",
              "D0ICEAASHQoRdW5wYWNrZWRfc2ZpeGVkNjQYYyADKBBCAhAAEhoKDnVucGFj",
              "a2VkX2Zsb2F0GGQgAygCQgIQABIbCg91bnBhY2tlZF9kb3VibGUYZSADKAFC",
              "AhAAEhkKDXVucGFja2VkX2Jvb2wYZiADKAhCAhAAEjkKDXVucGFja2VkX2Vu",
              "dW0YZyADKA4yHi5wcm90b2J1Zl91bml0dGVzdC5Gb3JlaWduRW51bUICEAAi",
              "wAEKI1Rlc3RSZXBlYXRlZFNjYWxhckRpZmZlcmVudFRhZ1NpemVzEhgKEHJl",
              "cGVhdGVkX2ZpeGVkMzIYDCADKAcSFgoOcmVwZWF0ZWRfaW50MzIYDSADKAUS",
              "GQoQcmVwZWF0ZWRfZml4ZWQ2NBj+DyADKAYSFwoOcmVwZWF0ZWRfaW50NjQY",
              "/w8gAygDEhgKDnJlcGVhdGVkX2Zsb2F0GP7/DyADKAISGQoPcmVwZWF0ZWRf",
              "dWludDY0GP//DyADKAQiKAobVGVzdENvbW1lbnRJbmplY3Rpb25NZXNzYWdl",
              "EgkKAWEYASABKAkiDAoKRm9vUmVxdWVzdCINCgtGb29SZXNwb25zZSISChBG",
              "b29DbGllbnRNZXNzYWdlIhIKEEZvb1NlcnZlck1lc3NhZ2UiDAoKQmFyUmVx",
              "dWVzdCINCgtCYXJSZXNwb25zZSpZCgtGb3JlaWduRW51bRIXChNGT1JFSUdO",
              "X1VOU1BFQ0lGSUVEEAASDwoLRk9SRUlHTl9GT08QBBIPCgtGT1JFSUdOX0JB",
              "UhAFEg8KC0ZPUkVJR05fQkFaEAYqdQoUVGVzdEVudW1XaXRoRHVwVmFsdWUS",
              "KAokVEVTVF9FTlVNX1dJVEhfRFVQX1ZBTFVFX1VOU1BFQ0lGSUVEEAASCAoE",
              "Rk9PMRABEggKBEJBUjEQAhIHCgNCQVoQAxIICgRGT08yEAESCAoEQkFSMhAC",
              "GgIQASqdAQoOVGVzdFNwYXJzZUVudW0SIAocVEVTVF9TUEFSU0VfRU5VTV9V",
              "TlNQRUNJRklFRBAAEgwKCFNQQVJTRV9BEHsSDgoIU1BBUlNFX0IQpucDEg8K",
              "CFNQQVJTRV9DELKxgAYSFQoIU1BBUlNFX0QQ8f//////////ARIVCghTUEFS",
              "U0VfRRC03vz///////8BEgwKCFNQQVJTRV9HEAIymQEKC1Rlc3RTZXJ2aWNl",
              "EkQKA0ZvbxIdLnByb3RvYnVmX3VuaXR0ZXN0LkZvb1JlcXVlc3QaHi5wcm90",
              "b2J1Zl91bml0dGVzdC5Gb29SZXNwb25zZRJECgNCYXISHS5wcm90b2J1Zl91",
              "bml0dGVzdC5CYXJSZXF1ZXN0Gh4ucHJvdG9idWZfdW5pdHRlc3QuQmFyUmVz",
              "cG9uc2VCOkINVW5pdHRlc3RQcm90b0gBgAEBiAEBkAEB+AEBqgIaR29vZ2xl",
              "LlByb3RvYnVmLlRlc3RQcm90b3NiBnByb3RvMw=="))
    FileDescriptor.FromGeneratedCode(descriptorData,
        [| ProtobufUnittestImport.UnittestImportProto3Reflection.Descriptor; |],
        new GeneratedClrTypeInfo(
          [|typeof<ForeignEnum>; typeof<TestEnumWithDupValue>; typeof<TestSparseEnum>; |],
          [|
            new GeneratedClrTypeInfo(typeof<TestAllTypes>, TestAllTypes.Parser, [| "SingleInt32"; "SingleInt64"; "SingleUint32"; "SingleUint64"; "SingleSint32"; "SingleSint64"; "SingleFixed32"; "SingleFixed64"; "SingleSfixed32"; "SingleSfixed64"; "SingleFloat"; "SingleDouble"; "SingleBool"; "SingleString"; "SingleBytes"; "SingleNestedMessage"; "SingleForeignMessage"; "SingleImportMessage"; "SingleNestedEnum"; "SingleForeignEnum"; "SingleImportEnum"; "SinglePublicImportMessage"; "RepeatedInt32"; "RepeatedInt64"; "RepeatedUint32"; "RepeatedUint64"; "RepeatedSint32"; "RepeatedSint64"; "RepeatedFixed32"; "RepeatedFixed64"; "RepeatedSfixed32"; "RepeatedSfixed64"; "RepeatedFloat"; "RepeatedDouble"; "RepeatedBool"; "RepeatedString"; "RepeatedBytes"; "RepeatedNestedMessage"; "RepeatedForeignMessage"; "RepeatedImportMessage"; "RepeatedNestedEnum"; "RepeatedForeignEnum"; "RepeatedImportEnum"; "RepeatedPublicImportMessage"; "OneofUint32_FSharp"; "OneofNestedMessage_FSharp"; "OneofString_FSharp"; "OneofBytes_FSharp" |], [| "OneofField_FSharp" |], [| typeof<TestAllTypes_NestedEnum> |], [|new GeneratedClrTypeInfo(typeof<TestAllTypes_NestedMessage>, TestAllTypes_NestedMessage.Parser, [| "Bb" |], null, null, null)|]);
            new GeneratedClrTypeInfo(typeof<NestedTestAllTypes>, NestedTestAllTypes.Parser, [| "Child"; "Payload"; "RepeatedChild" |], null, null, null);
            new GeneratedClrTypeInfo(typeof<TestDeprecatedFields>, TestDeprecatedFields.Parser, [| "DeprecatedInt32" |], null, null, null);
            new GeneratedClrTypeInfo(typeof<ForeignMessage>, ForeignMessage.Parser, [| "C" |], null, null, null);
            new GeneratedClrTypeInfo(typeof<TestReservedFields>, TestReservedFields.Parser, null, null, null, null);
            new GeneratedClrTypeInfo(typeof<TestForeignNested>, TestForeignNested.Parser, [| "ForeignNested" |], null, null, null);
            new GeneratedClrTypeInfo(typeof<TestReallyLargeTagNumber>, TestReallyLargeTagNumber.Parser, [| "A"; "Bb" |], null, null, null);
            new GeneratedClrTypeInfo(typeof<TestRecursiveMessage>, TestRecursiveMessage.Parser, [| "A"; "I" |], null, null, null);
            new GeneratedClrTypeInfo(typeof<TestMutualRecursionA>, TestMutualRecursionA.Parser, [| "Bb" |], null, null, null);
            new GeneratedClrTypeInfo(typeof<TestMutualRecursionB>, TestMutualRecursionB.Parser, [| "A"; "OptionalInt32" |], null, null, null);
            new GeneratedClrTypeInfo(typeof<TestEnumAllowAlias>, TestEnumAllowAlias.Parser, [| "Value" |], null, null, null);
            new GeneratedClrTypeInfo(typeof<TestCamelCaseFieldNames>, TestCamelCaseFieldNames.Parser, [| "PrimitiveField"; "StringField"; "EnumField"; "MessageField"; "RepeatedPrimitiveField"; "RepeatedStringField"; "RepeatedEnumField"; "RepeatedMessageField" |], null, null, null);
            new GeneratedClrTypeInfo(typeof<TestFieldOrderings>, TestFieldOrderings.Parser, [| "MyString"; "MyInt"; "MyFloat"; "SingleNestedMessage" |], null, null, [|new GeneratedClrTypeInfo(typeof<TestFieldOrderings_NestedMessage>, TestFieldOrderings_NestedMessage.Parser, [| "Oo"; "Bb" |], null, null, null)|]);
            new GeneratedClrTypeInfo(typeof<SparseEnumMessage>, SparseEnumMessage.Parser, [| "SparseEnum" |], null, null, null);
            new GeneratedClrTypeInfo(typeof<OneString>, OneString.Parser, [| "Data" |], null, null, null);
            new GeneratedClrTypeInfo(typeof<MoreString>, MoreString.Parser, [| "Data" |], null, null, null);
            new GeneratedClrTypeInfo(typeof<OneBytes>, OneBytes.Parser, [| "Data" |], null, null, null);
            new GeneratedClrTypeInfo(typeof<MoreBytes>, MoreBytes.Parser, [| "Data" |], null, null, null);
            new GeneratedClrTypeInfo(typeof<Int32Message>, Int32Message.Parser, [| "Data" |], null, null, null);
            new GeneratedClrTypeInfo(typeof<Uint32Message>, Uint32Message.Parser, [| "Data" |], null, null, null);
            new GeneratedClrTypeInfo(typeof<Int64Message>, Int64Message.Parser, [| "Data" |], null, null, null);
            new GeneratedClrTypeInfo(typeof<Uint64Message>, Uint64Message.Parser, [| "Data" |], null, null, null);
            new GeneratedClrTypeInfo(typeof<BoolMessage>, BoolMessage.Parser, [| "Data" |], null, null, null);
            new GeneratedClrTypeInfo(typeof<TestOneof>, TestOneof.Parser, [| "FooInt_FSharp"; "FooString_FSharp"; "FooMessage_FSharp" |], [| "Foo_FSharp" |], null, null);
            new GeneratedClrTypeInfo(typeof<TestPackedTypes>, TestPackedTypes.Parser, [| "PackedInt32"; "PackedInt64"; "PackedUint32"; "PackedUint64"; "PackedSint32"; "PackedSint64"; "PackedFixed32"; "PackedFixed64"; "PackedSfixed32"; "PackedSfixed64"; "PackedFloat"; "PackedDouble"; "PackedBool"; "PackedEnum" |], null, null, null);
            new GeneratedClrTypeInfo(typeof<TestUnpackedTypes>, TestUnpackedTypes.Parser, [| "UnpackedInt32"; "UnpackedInt64"; "UnpackedUint32"; "UnpackedUint64"; "UnpackedSint32"; "UnpackedSint64"; "UnpackedFixed32"; "UnpackedFixed64"; "UnpackedSfixed32"; "UnpackedSfixed64"; "UnpackedFloat"; "UnpackedDouble"; "UnpackedBool"; "UnpackedEnum" |], null, null, null);
            new GeneratedClrTypeInfo(typeof<TestRepeatedScalarDifferentTagSizes>, TestRepeatedScalarDifferentTagSizes.Parser, [| "RepeatedFixed32"; "RepeatedInt32"; "RepeatedFixed64"; "RepeatedInt64"; "RepeatedFloat"; "RepeatedUint64" |], null, null, null);
            new GeneratedClrTypeInfo(typeof<TestCommentInjectionMessage>, TestCommentInjectionMessage.Parser, [| "A" |], null, null, null);
            new GeneratedClrTypeInfo(typeof<FooRequest>, FooRequest.Parser, null, null, null, null);
            new GeneratedClrTypeInfo(typeof<FooResponse>, FooResponse.Parser, null, null, null, null);
            new GeneratedClrTypeInfo(typeof<FooClientMessage>, FooClientMessage.Parser, null, null, null, null);
            new GeneratedClrTypeInfo(typeof<FooServerMessage>, FooServerMessage.Parser, null, null, null, null);
            new GeneratedClrTypeInfo(typeof<BarRequest>, BarRequest.Parser, null, null, null, null);
            new GeneratedClrTypeInfo(typeof<BarResponse>, BarResponse.Parser, null, null, null, null)
          |]))

  static member val Descriptor = descriptor

// #region Enums
and public ForeignEnum =
  | [<OriginalName("FOREIGN_UNSPECIFIED")>] ForeignUnspecified = 0
  | [<OriginalName("FOREIGN_FOO")>] ForeignFoo = 4
  | [<OriginalName("FOREIGN_BAR")>] ForeignBar = 5
  | [<OriginalName("FOREIGN_BAZ")>] ForeignBaz = 6

/// <summary>
/// Test an enum that has multiple values with the same number.
/// </summary>
and public TestEnumWithDupValue =
  | [<OriginalName("TEST_ENUM_WITH_DUP_VALUE_UNSPECIFIED")>] Unspecified = 0
  | [<OriginalName("FOO1")>] Foo1 = 1
  | [<OriginalName("BAR1")>] Bar1 = 2
  | [<OriginalName("BAZ")>] Baz = 3
  | [<OriginalName("FOO2", PreferredAlias = false)>] Foo2 = 1
  | [<OriginalName("BAR2", PreferredAlias = false)>] Bar2 = 2

/// <summary>
/// Test an enum with large, unordered values.
/// </summary>
and public TestSparseEnum =
  | [<OriginalName("TEST_SPARSE_ENUM_UNSPECIFIED")>] Unspecified = 0
  | [<OriginalName("SPARSE_A")>] SparseA = 123
  | [<OriginalName("SPARSE_B")>] SparseB = 62374
  | [<OriginalName("SPARSE_C")>] SparseC = 12589234
  | [<OriginalName("SPARSE_D")>] SparseD = -15
  | [<OriginalName("SPARSE_E")>] SparseE = -53452
  /// <summary>
  /// In proto3, value 0 must be the first one specified
  /// SPARSE_F = 0;
  /// </summary>
  | [<OriginalName("SPARSE_G")>] SparseG = 2

// #endregion Enums

and TestAllTypes_OneofField =
  | OneofNone
  | OneofUint32 of uint32
  | OneofNestedMessage of TestAllTypes_NestedMessage
  | OneofString of string
  | OneofBytes of ByteString

/// <summary>
/// This proto includes every type of field in both singular and repeated
/// forms.
/// </summary>
and [<AllowNullLiteral>] public TestAllTypes =
  val mutable private singleInt32_ : int
  val mutable private singleInt64_ : int64
  val mutable private singleUint32_ : uint32
  val mutable private singleUint64_ : uint64
  val mutable private singleSint32_ : int
  val mutable private singleSint64_ : int64
  val mutable private singleFixed32_ : uint32
  val mutable private singleFixed64_ : uint64
  val mutable private singleSfixed32_ : int
  val mutable private singleSfixed64_ : int64
  val mutable private singleFloat_ : single
  val mutable private singleDouble_ : double
  val mutable private singleBool_ : bool
  val mutable private singleString_ : string
  val mutable private singleBytes_ : ByteString
  val mutable private singleNestedMessage_ : TestAllTypes_NestedMessage
  val mutable private singleForeignMessage_ : ForeignMessage
  val mutable private singleImportMessage_ : ProtobufUnittestImport.ImportMessage
  val mutable private singleNestedEnum_ : TestAllTypes_NestedEnum
  val mutable private singleForeignEnum_ : ForeignEnum
  val mutable private singleImportEnum_ : ProtobufUnittestImport.ImportEnum
  val mutable private singlePublicImportMessage_ : ProtobufUnittestImport.PublicImportMessage
  val mutable private repeatedInt32_ : RepeatedField<int>
  val mutable private repeatedInt64_ : RepeatedField<int64>
  val mutable private repeatedUint32_ : RepeatedField<uint32>
  val mutable private repeatedUint64_ : RepeatedField<uint64>
  val mutable private repeatedSint32_ : RepeatedField<int>
  val mutable private repeatedSint64_ : RepeatedField<int64>
  val mutable private repeatedFixed32_ : RepeatedField<uint32>
  val mutable private repeatedFixed64_ : RepeatedField<uint64>
  val mutable private repeatedSfixed32_ : RepeatedField<int>
  val mutable private repeatedSfixed64_ : RepeatedField<int64>
  val mutable private repeatedFloat_ : RepeatedField<single>
  val mutable private repeatedDouble_ : RepeatedField<double>
  val mutable private repeatedBool_ : RepeatedField<bool>
  val mutable private repeatedString_ : RepeatedField<string>
  val mutable private repeatedBytes_ : RepeatedField<ByteString>
  val mutable private repeatedNestedMessage_ : RepeatedField<TestAllTypes_NestedMessage>
  val mutable private repeatedForeignMessage_ : RepeatedField<ForeignMessage>
  val mutable private repeatedImportMessage_ : RepeatedField<ProtobufUnittestImport.ImportMessage>
  val mutable private repeatedNestedEnum_ : RepeatedField<TestAllTypes_NestedEnum>
  val mutable private repeatedForeignEnum_ : RepeatedField<ForeignEnum>
  val mutable private repeatedImportEnum_ : RepeatedField<ProtobufUnittestImport.ImportEnum>
  val mutable private repeatedPublicImportMessage_ : RepeatedField<ProtobufUnittestImport.PublicImportMessage>
  val mutable private oneofField_ : TestAllTypes_OneofField

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      singleInt32_ = Unchecked.defaultof<int>
      singleInt64_ = Unchecked.defaultof<int64>
      singleUint32_ = Unchecked.defaultof<uint32>
      singleUint64_ = Unchecked.defaultof<uint64>
      singleSint32_ = Unchecked.defaultof<int>
      singleSint64_ = Unchecked.defaultof<int64>
      singleFixed32_ = Unchecked.defaultof<uint32>
      singleFixed64_ = Unchecked.defaultof<uint64>
      singleSfixed32_ = Unchecked.defaultof<int>
      singleSfixed64_ = Unchecked.defaultof<int64>
      singleFloat_ = Unchecked.defaultof<single>
      singleDouble_ = Unchecked.defaultof<double>
      singleBool_ = Unchecked.defaultof<bool>
      singleString_ = ""
      singleBytes_ = ByteString.Empty
      singleNestedMessage_ = null
      singleForeignMessage_ = null
      singleImportMessage_ = null
      singleNestedEnum_ = enum 0
      singleForeignEnum_ = enum 0
      singleImportEnum_ = enum 0
      singlePublicImportMessage_ = null
      repeatedInt32_ = new RepeatedField<int>()
      repeatedInt64_ = new RepeatedField<int64>()
      repeatedUint32_ = new RepeatedField<uint32>()
      repeatedUint64_ = new RepeatedField<uint64>()
      repeatedSint32_ = new RepeatedField<int>()
      repeatedSint64_ = new RepeatedField<int64>()
      repeatedFixed32_ = new RepeatedField<uint32>()
      repeatedFixed64_ = new RepeatedField<uint64>()
      repeatedSfixed32_ = new RepeatedField<int>()
      repeatedSfixed64_ = new RepeatedField<int64>()
      repeatedFloat_ = new RepeatedField<single>()
      repeatedDouble_ = new RepeatedField<double>()
      repeatedBool_ = new RepeatedField<bool>()
      repeatedString_ = new RepeatedField<string>()
      repeatedBytes_ = new RepeatedField<ByteString>()
      repeatedNestedMessage_ = new RepeatedField<TestAllTypes_NestedMessage>()
      repeatedForeignMessage_ = new RepeatedField<ForeignMessage>()
      repeatedImportMessage_ = new RepeatedField<ProtobufUnittestImport.ImportMessage>()
      repeatedNestedEnum_ = new RepeatedField<TestAllTypes_NestedEnum>()
      repeatedForeignEnum_ = new RepeatedField<ForeignEnum>()
      repeatedImportEnum_ = new RepeatedField<ProtobufUnittestImport.ImportEnum>()
      repeatedPublicImportMessage_ = new RepeatedField<ProtobufUnittestImport.PublicImportMessage>()
      oneofField_ = TestAllTypes_OneofField.OneofNone
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: TestAllTypes) =
    {
      singleInt32_ = other.singleInt32_
      singleInt64_ = other.singleInt64_
      singleUint32_ = other.singleUint32_
      singleUint64_ = other.singleUint64_
      singleSint32_ = other.singleSint32_
      singleSint64_ = other.singleSint64_
      singleFixed32_ = other.singleFixed32_
      singleFixed64_ = other.singleFixed64_
      singleSfixed32_ = other.singleSfixed32_
      singleSfixed64_ = other.singleSfixed64_
      singleFloat_ = other.singleFloat_
      singleDouble_ = other.singleDouble_
      singleBool_ = other.singleBool_
      singleString_ = other.singleString_
      singleBytes_ = other.singleBytes_
      singleNestedMessage_ = if other.singleNestedMessage_ <> null then (other.singleNestedMessage_ :> IDeepCloneable<_>).Clone() else null
      singleForeignMessage_ = if other.singleForeignMessage_ <> null then (other.singleForeignMessage_ :> IDeepCloneable<_>).Clone() else null
      singleImportMessage_ = if other.singleImportMessage_ <> null then (other.singleImportMessage_ :> IDeepCloneable<_>).Clone() else null
      singleNestedEnum_ = other.singleNestedEnum_
      singleForeignEnum_ = other.singleForeignEnum_
      singleImportEnum_ = other.singleImportEnum_
      singlePublicImportMessage_ = if other.singlePublicImportMessage_ <> null then (other.singlePublicImportMessage_ :> IDeepCloneable<_>).Clone() else null
      repeatedInt32_ = other.repeatedInt32_.Clone()
      repeatedInt64_ = other.repeatedInt64_.Clone()
      repeatedUint32_ = other.repeatedUint32_.Clone()
      repeatedUint64_ = other.repeatedUint64_.Clone()
      repeatedSint32_ = other.repeatedSint32_.Clone()
      repeatedSint64_ = other.repeatedSint64_.Clone()
      repeatedFixed32_ = other.repeatedFixed32_.Clone()
      repeatedFixed64_ = other.repeatedFixed64_.Clone()
      repeatedSfixed32_ = other.repeatedSfixed32_.Clone()
      repeatedSfixed64_ = other.repeatedSfixed64_.Clone()
      repeatedFloat_ = other.repeatedFloat_.Clone()
      repeatedDouble_ = other.repeatedDouble_.Clone()
      repeatedBool_ = other.repeatedBool_.Clone()
      repeatedString_ = other.repeatedString_.Clone()
      repeatedBytes_ = other.repeatedBytes_.Clone()
      repeatedNestedMessage_ = other.repeatedNestedMessage_.Clone()
      repeatedForeignMessage_ = other.repeatedForeignMessage_.Clone()
      repeatedImportMessage_ = other.repeatedImportMessage_.Clone()
      repeatedNestedEnum_ = other.repeatedNestedEnum_.Clone()
      repeatedForeignEnum_ = other.repeatedForeignEnum_.Clone()
      repeatedImportEnum_ = other.repeatedImportEnum_.Clone()
      repeatedPublicImportMessage_ = other.repeatedPublicImportMessage_.Clone()
      oneofField_ =
        match other.oneofField_ with
        | TestAllTypes_OneofField.OneofUint32 x -> TestAllTypes_OneofField.OneofUint32 x
        | TestAllTypes_OneofField.OneofNestedMessage x -> TestAllTypes_OneofField.OneofNestedMessage ((x :> IDeepCloneable<_>).Clone())
        | TestAllTypes_OneofField.OneofString x -> TestAllTypes_OneofField.OneofString x
        | TestAllTypes_OneofField.OneofBytes x -> TestAllTypes_OneofField.OneofBytes x
        | TestAllTypes_OneofField.OneofNone -> TestAllTypes_OneofField.OneofNone
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<TestAllTypes>(fun () -> new TestAllTypes())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[0]

  /// <summary>Field number for the "single_int32" field.</summary>
  static member public SingleInt32FieldNumber = 1
  /// <summary>
  /// Singular
  /// </summary>
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.SingleInt32
    with get() = this.singleInt32_
    and set(value: int) =
      this.singleInt32_ <- value


  /// <summary>Field number for the "single_int64" field.</summary>
  static member public SingleInt64FieldNumber = 2
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.SingleInt64
    with get() = this.singleInt64_
    and set(value: int64) =
      this.singleInt64_ <- value


  /// <summary>Field number for the "single_uint32" field.</summary>
  static member public SingleUint32FieldNumber = 3
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.SingleUint32
    with get() = this.singleUint32_
    and set(value: uint32) =
      this.singleUint32_ <- value


  /// <summary>Field number for the "single_uint64" field.</summary>
  static member public SingleUint64FieldNumber = 4
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.SingleUint64
    with get() = this.singleUint64_
    and set(value: uint64) =
      this.singleUint64_ <- value


  /// <summary>Field number for the "single_sint32" field.</summary>
  static member public SingleSint32FieldNumber = 5
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.SingleSint32
    with get() = this.singleSint32_
    and set(value: int) =
      this.singleSint32_ <- value


  /// <summary>Field number for the "single_sint64" field.</summary>
  static member public SingleSint64FieldNumber = 6
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.SingleSint64
    with get() = this.singleSint64_
    and set(value: int64) =
      this.singleSint64_ <- value


  /// <summary>Field number for the "single_fixed32" field.</summary>
  static member public SingleFixed32FieldNumber = 7
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.SingleFixed32
    with get() = this.singleFixed32_
    and set(value: uint32) =
      this.singleFixed32_ <- value


  /// <summary>Field number for the "single_fixed64" field.</summary>
  static member public SingleFixed64FieldNumber = 8
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.SingleFixed64
    with get() = this.singleFixed64_
    and set(value: uint64) =
      this.singleFixed64_ <- value


  /// <summary>Field number for the "single_sfixed32" field.</summary>
  static member public SingleSfixed32FieldNumber = 9
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.SingleSfixed32
    with get() = this.singleSfixed32_
    and set(value: int) =
      this.singleSfixed32_ <- value


  /// <summary>Field number for the "single_sfixed64" field.</summary>
  static member public SingleSfixed64FieldNumber = 10
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.SingleSfixed64
    with get() = this.singleSfixed64_
    and set(value: int64) =
      this.singleSfixed64_ <- value


  /// <summary>Field number for the "single_float" field.</summary>
  static member public SingleFloatFieldNumber = 11
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.SingleFloat
    with get() = this.singleFloat_
    and set(value: single) =
      this.singleFloat_ <- value


  /// <summary>Field number for the "single_double" field.</summary>
  static member public SingleDoubleFieldNumber = 12
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.SingleDouble
    with get() = this.singleDouble_
    and set(value: double) =
      this.singleDouble_ <- value


  /// <summary>Field number for the "single_bool" field.</summary>
  static member public SingleBoolFieldNumber = 13
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.SingleBool
    with get() = this.singleBool_
    and set(value: bool) =
      this.singleBool_ <- value


  /// <summary>Field number for the "single_string" field.</summary>
  static member public SingleStringFieldNumber = 14
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.SingleString
    with get() = this.singleString_
    and set(value: string) =
      if value <> null then
        this.singleString_ <- value


  /// <summary>Field number for the "single_bytes" field.</summary>
  static member public SingleBytesFieldNumber = 15
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.SingleBytes
    with get() = this.singleBytes_
    and set(value: ByteString) =
      if value <> null then
        this.singleBytes_ <- value


  /// <summary>Field number for the "single_nested_message" field.</summary>
  static member public SingleNestedMessageFieldNumber = 18
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.SingleNestedMessage
    with get () = this.singleNestedMessage_
    and set(value: TestAllTypes_NestedMessage) =
      this.singleNestedMessage_ <- value

  /// <summary>Field number for the "single_foreign_message" field.</summary>
  static member public SingleForeignMessageFieldNumber = 19
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.SingleForeignMessage
    with get () = this.singleForeignMessage_
    and set(value: ForeignMessage) =
      this.singleForeignMessage_ <- value

  /// <summary>Field number for the "single_import_message" field.</summary>
  static member public SingleImportMessageFieldNumber = 20
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.SingleImportMessage
    with get () = this.singleImportMessage_
    and set(value: ProtobufUnittestImport.ImportMessage) =
      this.singleImportMessage_ <- value

  /// <summary>Field number for the "single_nested_enum" field.</summary>
  static member public SingleNestedEnumFieldNumber = 21
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.SingleNestedEnum
    with get() = this.singleNestedEnum_
    and set(value: TestAllTypes_NestedEnum) =
      this.singleNestedEnum_ <- value


  /// <summary>Field number for the "single_foreign_enum" field.</summary>
  static member public SingleForeignEnumFieldNumber = 22
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.SingleForeignEnum
    with get() = this.singleForeignEnum_
    and set(value: ForeignEnum) =
      this.singleForeignEnum_ <- value


  /// <summary>Field number for the "single_import_enum" field.</summary>
  static member public SingleImportEnumFieldNumber = 23
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.SingleImportEnum
    with get() = this.singleImportEnum_
    and set(value: ProtobufUnittestImport.ImportEnum) =
      this.singleImportEnum_ <- value


  /// <summary>Field number for the "single_public_import_message" field.</summary>
  static member public SinglePublicImportMessageFieldNumber = 26
  /// <summary>
  /// Defined in unittest_import_public.proto
  /// </summary>
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.SinglePublicImportMessage
    with get () = this.singlePublicImportMessage_
    and set(value: ProtobufUnittestImport.PublicImportMessage) =
      this.singlePublicImportMessage_ <- value

  /// <summary>Field number for the "repeated_int32" field.</summary>
  static member public RepeatedInt32FieldNumber = 31
  static member private _repeated_repeatedInt32_codec =
    FieldCodec.ForInt32(250u)
  /// <summary>
  /// Repeated
  /// </summary>
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedInt32
    with get() = this.repeatedInt32_

  /// <summary>Field number for the "repeated_int64" field.</summary>
  static member public RepeatedInt64FieldNumber = 32
  static member private _repeated_repeatedInt64_codec =
    FieldCodec.ForInt64(258u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedInt64
    with get() = this.repeatedInt64_

  /// <summary>Field number for the "repeated_uint32" field.</summary>
  static member public RepeatedUint32FieldNumber = 33
  static member private _repeated_repeatedUint32_codec =
    FieldCodec.ForUInt32(266u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedUint32
    with get() = this.repeatedUint32_

  /// <summary>Field number for the "repeated_uint64" field.</summary>
  static member public RepeatedUint64FieldNumber = 34
  static member private _repeated_repeatedUint64_codec =
    FieldCodec.ForUInt64(274u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedUint64
    with get() = this.repeatedUint64_

  /// <summary>Field number for the "repeated_sint32" field.</summary>
  static member public RepeatedSint32FieldNumber = 35
  static member private _repeated_repeatedSint32_codec =
    FieldCodec.ForSInt32(282u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedSint32
    with get() = this.repeatedSint32_

  /// <summary>Field number for the "repeated_sint64" field.</summary>
  static member public RepeatedSint64FieldNumber = 36
  static member private _repeated_repeatedSint64_codec =
    FieldCodec.ForSInt64(290u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedSint64
    with get() = this.repeatedSint64_

  /// <summary>Field number for the "repeated_fixed32" field.</summary>
  static member public RepeatedFixed32FieldNumber = 37
  static member private _repeated_repeatedFixed32_codec =
    FieldCodec.ForFixed32(298u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedFixed32
    with get() = this.repeatedFixed32_

  /// <summary>Field number for the "repeated_fixed64" field.</summary>
  static member public RepeatedFixed64FieldNumber = 38
  static member private _repeated_repeatedFixed64_codec =
    FieldCodec.ForFixed64(306u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedFixed64
    with get() = this.repeatedFixed64_

  /// <summary>Field number for the "repeated_sfixed32" field.</summary>
  static member public RepeatedSfixed32FieldNumber = 39
  static member private _repeated_repeatedSfixed32_codec =
    FieldCodec.ForSFixed32(314u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedSfixed32
    with get() = this.repeatedSfixed32_

  /// <summary>Field number for the "repeated_sfixed64" field.</summary>
  static member public RepeatedSfixed64FieldNumber = 40
  static member private _repeated_repeatedSfixed64_codec =
    FieldCodec.ForSFixed64(322u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedSfixed64
    with get() = this.repeatedSfixed64_

  /// <summary>Field number for the "repeated_float" field.</summary>
  static member public RepeatedFloatFieldNumber = 41
  static member private _repeated_repeatedFloat_codec =
    FieldCodec.ForFloat(330u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedFloat
    with get() = this.repeatedFloat_

  /// <summary>Field number for the "repeated_double" field.</summary>
  static member public RepeatedDoubleFieldNumber = 42
  static member private _repeated_repeatedDouble_codec =
    FieldCodec.ForDouble(338u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedDouble
    with get() = this.repeatedDouble_

  /// <summary>Field number for the "repeated_bool" field.</summary>
  static member public RepeatedBoolFieldNumber = 43
  static member private _repeated_repeatedBool_codec =
    FieldCodec.ForBool(346u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedBool
    with get() = this.repeatedBool_

  /// <summary>Field number for the "repeated_string" field.</summary>
  static member public RepeatedStringFieldNumber = 44
  static member private _repeated_repeatedString_codec =
    FieldCodec.ForString(354u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedString
    with get() = this.repeatedString_

  /// <summary>Field number for the "repeated_bytes" field.</summary>
  static member public RepeatedBytesFieldNumber = 45
  static member private _repeated_repeatedBytes_codec =
    FieldCodec.ForBytes(362u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedBytes
    with get() = this.repeatedBytes_

  /// <summary>Field number for the "repeated_nested_message" field.</summary>
  static member public RepeatedNestedMessageFieldNumber = 48
  static member private _repeated_repeatedNestedMessage_codec =
    FieldCodec.ForMessage(386u, TestAllTypes_NestedMessage.Parser)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedNestedMessage
    with get() = this.repeatedNestedMessage_

  /// <summary>Field number for the "repeated_foreign_message" field.</summary>
  static member public RepeatedForeignMessageFieldNumber = 49
  static member private _repeated_repeatedForeignMessage_codec =
    FieldCodec.ForMessage(394u, ForeignMessage.Parser)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedForeignMessage
    with get() = this.repeatedForeignMessage_

  /// <summary>Field number for the "repeated_import_message" field.</summary>
  static member public RepeatedImportMessageFieldNumber = 50
  static member private _repeated_repeatedImportMessage_codec =
    FieldCodec.ForMessage(402u, ProtobufUnittestImport.ImportMessage.Parser)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedImportMessage
    with get() = this.repeatedImportMessage_

  /// <summary>Field number for the "repeated_nested_enum" field.</summary>
  static member public RepeatedNestedEnumFieldNumber = 51
  static member private _repeated_repeatedNestedEnum_codec =
    FieldCodec.ForEnum(410u, (fun x -> int x), (fun x -> enum x))
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedNestedEnum
    with get() = this.repeatedNestedEnum_

  /// <summary>Field number for the "repeated_foreign_enum" field.</summary>
  static member public RepeatedForeignEnumFieldNumber = 52
  static member private _repeated_repeatedForeignEnum_codec =
    FieldCodec.ForEnum(418u, (fun x -> int x), (fun x -> enum x))
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedForeignEnum
    with get() = this.repeatedForeignEnum_

  /// <summary>Field number for the "repeated_import_enum" field.</summary>
  static member public RepeatedImportEnumFieldNumber = 53
  static member private _repeated_repeatedImportEnum_codec =
    FieldCodec.ForEnum(426u, (fun x -> int x), (fun x -> enum x))
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedImportEnum
    with get() = this.repeatedImportEnum_

  /// <summary>Field number for the "repeated_public_import_message" field.</summary>
  static member public RepeatedPublicImportMessageFieldNumber = 54
  static member private _repeated_repeatedPublicImportMessage_codec =
    FieldCodec.ForMessage(434u, ProtobufUnittestImport.PublicImportMessage.Parser)
  /// <summary>
  /// Defined in unittest_import_public.proto
  /// </summary>
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedPublicImportMessage
    with get() = this.repeatedPublicImportMessage_

  /// <summary>Field number for the "oneof_uint32" field.</summary>
  static member public OneofUint32FieldNumber = 111

  /// <summary>Field number for the "oneof_nested_message" field.</summary>
  static member public OneofNestedMessageFieldNumber = 112

  /// <summary>Field number for the "oneof_string" field.</summary>
  static member public OneofStringFieldNumber = 113

  /// <summary>Field number for the "oneof_bytes" field.</summary>
  static member public OneofBytesFieldNumber = 114

  member public this.OneofField
    with get () = this.oneofField_
    and set(value: TestAllTypes_OneofField) =
      this.oneofField_ <- value

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? TestAllTypes as x -> (x :> System.IEquatable<TestAllTypes>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    if this.SingleInt32 <> 0 then hash <- hash ^^^ this.SingleInt32.GetHashCode()
    if this.SingleInt64 <> 0L then hash <- hash ^^^ this.SingleInt64.GetHashCode()
    if this.SingleUint32 <> 0u then hash <- hash ^^^ this.SingleUint32.GetHashCode()
    if this.SingleUint64 <> 0UL then hash <- hash ^^^ this.SingleUint64.GetHashCode()
    if this.SingleSint32 <> 0 then hash <- hash ^^^ this.SingleSint32.GetHashCode()
    if this.SingleSint64 <> 0L then hash <- hash ^^^ this.SingleSint64.GetHashCode()
    if this.SingleFixed32 <> 0u then hash <- hash ^^^ this.SingleFixed32.GetHashCode()
    if this.SingleFixed64 <> 0UL then hash <- hash ^^^ this.SingleFixed64.GetHashCode()
    if this.SingleSfixed32 <> 0 then hash <- hash ^^^ this.SingleSfixed32.GetHashCode()
    if this.SingleSfixed64 <> 0L then hash <- hash ^^^ this.SingleSfixed64.GetHashCode()
    if this.SingleFloat <> 0.0f then hash <- hash ^^^ this.SingleFloat.GetHashCode()
    if this.SingleDouble <> 0.0 then hash <- hash ^^^ this.SingleDouble.GetHashCode()
    if this.SingleBool <> false then hash <- hash ^^^ this.SingleBool.GetHashCode()
    if this.SingleString.Length <> 0 then hash <- hash ^^^ this.SingleString.GetHashCode()
    if this.SingleBytes.Length <> 0 then hash <- hash ^^^ this.SingleBytes.GetHashCode()
    if this.singleNestedMessage_ <> null then hash <- hash ^^^ this.SingleNestedMessage.GetHashCode()
    if this.singleForeignMessage_ <> null then hash <- hash ^^^ this.SingleForeignMessage.GetHashCode()
    if this.singleImportMessage_ <> null then hash <- hash ^^^ this.SingleImportMessage.GetHashCode()
    if this.SingleNestedEnum <> enum 0 then hash <- hash ^^^ this.SingleNestedEnum.GetHashCode()
    if this.SingleForeignEnum <> enum 0 then hash <- hash ^^^ this.SingleForeignEnum.GetHashCode()
    if this.SingleImportEnum <> enum 0 then hash <- hash ^^^ this.SingleImportEnum.GetHashCode()
    if this.singlePublicImportMessage_ <> null then hash <- hash ^^^ this.SinglePublicImportMessage.GetHashCode()
    hash <- hash ^^^ this.repeatedInt32_.GetHashCode()
    hash <- hash ^^^ this.repeatedInt64_.GetHashCode()
    hash <- hash ^^^ this.repeatedUint32_.GetHashCode()
    hash <- hash ^^^ this.repeatedUint64_.GetHashCode()
    hash <- hash ^^^ this.repeatedSint32_.GetHashCode()
    hash <- hash ^^^ this.repeatedSint64_.GetHashCode()
    hash <- hash ^^^ this.repeatedFixed32_.GetHashCode()
    hash <- hash ^^^ this.repeatedFixed64_.GetHashCode()
    hash <- hash ^^^ this.repeatedSfixed32_.GetHashCode()
    hash <- hash ^^^ this.repeatedSfixed64_.GetHashCode()
    hash <- hash ^^^ this.repeatedFloat_.GetHashCode()
    hash <- hash ^^^ this.repeatedDouble_.GetHashCode()
    hash <- hash ^^^ this.repeatedBool_.GetHashCode()
    hash <- hash ^^^ this.repeatedString_.GetHashCode()
    hash <- hash ^^^ this.repeatedBytes_.GetHashCode()
    hash <- hash ^^^ this.repeatedNestedMessage_.GetHashCode()
    hash <- hash ^^^ this.repeatedForeignMessage_.GetHashCode()
    hash <- hash ^^^ this.repeatedImportMessage_.GetHashCode()
    hash <- hash ^^^ this.repeatedNestedEnum_.GetHashCode()
    hash <- hash ^^^ this.repeatedForeignEnum_.GetHashCode()
    hash <- hash ^^^ this.repeatedImportEnum_.GetHashCode()
    hash <- hash ^^^ this.repeatedPublicImportMessage_.GetHashCode()
    match this.OneofField with
    | TestAllTypes_OneofField.OneofNone -> ()
    | TestAllTypes_OneofField.OneofUint32 x -> hash <- hash ^^^ x.GetHashCode() ^^^ 111
    | TestAllTypes_OneofField.OneofNestedMessage x -> hash <- hash ^^^ x.GetHashCode() ^^^ 112
    | TestAllTypes_OneofField.OneofString x -> hash <- hash ^^^ x.GetHashCode() ^^^ 113
    | TestAllTypes_OneofField.OneofBytes x -> hash <- hash ^^^ x.GetHashCode() ^^^ 114
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<TestAllTypes> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      if this.SingleInt32 <> 0 then
        output.WriteRawTag(8uy)
        output.WriteInt32(this.SingleInt32)

      if this.SingleInt64 <> 0L then
        output.WriteRawTag(16uy)
        output.WriteInt64(this.SingleInt64)

      if this.SingleUint32 <> 0u then
        output.WriteRawTag(24uy)
        output.WriteUInt32(this.SingleUint32)

      if this.SingleUint64 <> 0UL then
        output.WriteRawTag(32uy)
        output.WriteUInt64(this.SingleUint64)

      if this.SingleSint32 <> 0 then
        output.WriteRawTag(40uy)
        output.WriteSInt32(this.SingleSint32)

      if this.SingleSint64 <> 0L then
        output.WriteRawTag(48uy)
        output.WriteSInt64(this.SingleSint64)

      if this.SingleFixed32 <> 0u then
        output.WriteRawTag(61uy)
        output.WriteFixed32(this.SingleFixed32)

      if this.SingleFixed64 <> 0UL then
        output.WriteRawTag(65uy)
        output.WriteFixed64(this.SingleFixed64)

      if this.SingleSfixed32 <> 0 then
        output.WriteRawTag(77uy)
        output.WriteSFixed32(this.SingleSfixed32)

      if this.SingleSfixed64 <> 0L then
        output.WriteRawTag(81uy)
        output.WriteSFixed64(this.SingleSfixed64)

      if this.SingleFloat <> 0.0f then
        output.WriteRawTag(93uy)
        output.WriteFloat(this.SingleFloat)

      if this.SingleDouble <> 0.0 then
        output.WriteRawTag(97uy)
        output.WriteDouble(this.SingleDouble)

      if this.SingleBool <> false then
        output.WriteRawTag(104uy)
        output.WriteBool(this.SingleBool)

      if this.SingleString.Length <> 0 then
        output.WriteRawTag(114uy)
        output.WriteString(this.SingleString)

      if this.SingleBytes.Length <> 0 then
        output.WriteRawTag(122uy)
        output.WriteBytes(this.SingleBytes)

      if this.singleNestedMessage_ <> null then
        output.WriteRawTag(146uy, 1uy)
        output.WriteMessage(this.SingleNestedMessage)
      if this.singleForeignMessage_ <> null then
        output.WriteRawTag(154uy, 1uy)
        output.WriteMessage(this.SingleForeignMessage)
      if this.singleImportMessage_ <> null then
        output.WriteRawTag(162uy, 1uy)
        output.WriteMessage(this.SingleImportMessage)
      if this.SingleNestedEnum <> enum 0 then
        output.WriteRawTag(168uy, 1uy)
        output.WriteEnum(int this.SingleNestedEnum)
      if this.SingleForeignEnum <> enum 0 then
        output.WriteRawTag(176uy, 1uy)
        output.WriteEnum(int this.SingleForeignEnum)
      if this.SingleImportEnum <> enum 0 then
        output.WriteRawTag(184uy, 1uy)
        output.WriteEnum(int this.SingleImportEnum)
      if this.singlePublicImportMessage_ <> null then
        output.WriteRawTag(210uy, 1uy)
        output.WriteMessage(this.SinglePublicImportMessage)
      this.repeatedInt32_.WriteTo(output, TestAllTypes._repeated_repeatedInt32_codec)
      this.repeatedInt64_.WriteTo(output, TestAllTypes._repeated_repeatedInt64_codec)
      this.repeatedUint32_.WriteTo(output, TestAllTypes._repeated_repeatedUint32_codec)
      this.repeatedUint64_.WriteTo(output, TestAllTypes._repeated_repeatedUint64_codec)
      this.repeatedSint32_.WriteTo(output, TestAllTypes._repeated_repeatedSint32_codec)
      this.repeatedSint64_.WriteTo(output, TestAllTypes._repeated_repeatedSint64_codec)
      this.repeatedFixed32_.WriteTo(output, TestAllTypes._repeated_repeatedFixed32_codec)
      this.repeatedFixed64_.WriteTo(output, TestAllTypes._repeated_repeatedFixed64_codec)
      this.repeatedSfixed32_.WriteTo(output, TestAllTypes._repeated_repeatedSfixed32_codec)
      this.repeatedSfixed64_.WriteTo(output, TestAllTypes._repeated_repeatedSfixed64_codec)
      this.repeatedFloat_.WriteTo(output, TestAllTypes._repeated_repeatedFloat_codec)
      this.repeatedDouble_.WriteTo(output, TestAllTypes._repeated_repeatedDouble_codec)
      this.repeatedBool_.WriteTo(output, TestAllTypes._repeated_repeatedBool_codec)
      this.repeatedString_.WriteTo(output, TestAllTypes._repeated_repeatedString_codec)
      this.repeatedBytes_.WriteTo(output, TestAllTypes._repeated_repeatedBytes_codec)
      this.repeatedNestedMessage_.WriteTo(output, TestAllTypes._repeated_repeatedNestedMessage_codec)
      this.repeatedForeignMessage_.WriteTo(output, TestAllTypes._repeated_repeatedForeignMessage_codec)
      this.repeatedImportMessage_.WriteTo(output, TestAllTypes._repeated_repeatedImportMessage_codec)
      this.repeatedNestedEnum_.WriteTo(output, TestAllTypes._repeated_repeatedNestedEnum_codec)
      this.repeatedForeignEnum_.WriteTo(output, TestAllTypes._repeated_repeatedForeignEnum_codec)
      this.repeatedImportEnum_.WriteTo(output, TestAllTypes._repeated_repeatedImportEnum_codec)
      this.repeatedPublicImportMessage_.WriteTo(output, TestAllTypes._repeated_repeatedPublicImportMessage_codec)
      match this.oneofField_ with
        | TestAllTypes_OneofField.OneofUint32 x ->
          output.WriteRawTag(248uy, 6uy)
          output.WriteUInt32(x)
        | _ -> ()

      match this.oneofField_ with
        | TestAllTypes_OneofField.OneofNestedMessage x ->
          output.WriteRawTag(130uy, 7uy)
          output.WriteMessage(x)
        | _ -> ()

      match this.oneofField_ with
        | TestAllTypes_OneofField.OneofString x ->
          output.WriteRawTag(138uy, 7uy)
          output.WriteString(x)
        | _ -> ()

      match this.oneofField_ with
        | TestAllTypes_OneofField.OneofBytes x ->
          output.WriteRawTag(146uy, 7uy)
          output.WriteBytes(x)
        | _ -> ()


    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      if this.SingleInt32 <> 0 then
        size <- size + 1 + CodedOutputStream.ComputeInt32Size(this.SingleInt32)
      if this.SingleInt64 <> 0L then
        size <- size + 1 + CodedOutputStream.ComputeInt64Size(this.SingleInt64)
      if this.SingleUint32 <> 0u then
        size <- size + 1 + CodedOutputStream.ComputeUInt32Size(this.SingleUint32)
      if this.SingleUint64 <> 0UL then
        size <- size + 1 + CodedOutputStream.ComputeUInt64Size(this.SingleUint64)
      if this.SingleSint32 <> 0 then
        size <- size + 1 + CodedOutputStream.ComputeSInt32Size(this.SingleSint32)
      if this.SingleSint64 <> 0L then
        size <- size + 1 + CodedOutputStream.ComputeSInt64Size(this.SingleSint64)
      if this.SingleFixed32 <> 0u then
        size <- size + 1 + 4
      if this.SingleFixed64 <> 0UL then
        size <- size + 1 + 8
      if this.SingleSfixed32 <> 0 then
        size <- size + 1 + 4
      if this.SingleSfixed64 <> 0L then
        size <- size + 1 + 8
      if this.SingleFloat <> 0.0f then
        size <- size + 1 + 4
      if this.SingleDouble <> 0.0 then
        size <- size + 1 + 8
      if this.SingleBool <> false then
        size <- size + 1 + 1
      if this.SingleString.Length <> 0 then
        size <- size + 1 + CodedOutputStream.ComputeStringSize(this.SingleString)
      if this.SingleBytes.Length <> 0 then
        size <- size + 1 + CodedOutputStream.ComputeBytesSize(this.SingleBytes)
      if this.singleNestedMessage_ <> null then
        size <- size + 2 + CodedOutputStream.ComputeMessageSize(this.SingleNestedMessage)
      if this.singleForeignMessage_ <> null then
        size <- size + 2 + CodedOutputStream.ComputeMessageSize(this.SingleForeignMessage)
      if this.singleImportMessage_ <> null then
        size <- size + 2 + CodedOutputStream.ComputeMessageSize(this.SingleImportMessage)
      if this.SingleNestedEnum <> enum 0 then
        size <- size + 2 + CodedOutputStream.ComputeEnumSize(int this.SingleNestedEnum)
      if this.SingleForeignEnum <> enum 0 then
        size <- size + 2 + CodedOutputStream.ComputeEnumSize(int this.SingleForeignEnum)
      if this.SingleImportEnum <> enum 0 then
        size <- size + 2 + CodedOutputStream.ComputeEnumSize(int this.SingleImportEnum)
      if this.singlePublicImportMessage_ <> null then
        size <- size + 2 + CodedOutputStream.ComputeMessageSize(this.SinglePublicImportMessage)
      size <- size + this.repeatedInt32_.CalculateSize(TestAllTypes._repeated_repeatedInt32_codec)
      size <- size + this.repeatedInt64_.CalculateSize(TestAllTypes._repeated_repeatedInt64_codec)
      size <- size + this.repeatedUint32_.CalculateSize(TestAllTypes._repeated_repeatedUint32_codec)
      size <- size + this.repeatedUint64_.CalculateSize(TestAllTypes._repeated_repeatedUint64_codec)
      size <- size + this.repeatedSint32_.CalculateSize(TestAllTypes._repeated_repeatedSint32_codec)
      size <- size + this.repeatedSint64_.CalculateSize(TestAllTypes._repeated_repeatedSint64_codec)
      size <- size + this.repeatedFixed32_.CalculateSize(TestAllTypes._repeated_repeatedFixed32_codec)
      size <- size + this.repeatedFixed64_.CalculateSize(TestAllTypes._repeated_repeatedFixed64_codec)
      size <- size + this.repeatedSfixed32_.CalculateSize(TestAllTypes._repeated_repeatedSfixed32_codec)
      size <- size + this.repeatedSfixed64_.CalculateSize(TestAllTypes._repeated_repeatedSfixed64_codec)
      size <- size + this.repeatedFloat_.CalculateSize(TestAllTypes._repeated_repeatedFloat_codec)
      size <- size + this.repeatedDouble_.CalculateSize(TestAllTypes._repeated_repeatedDouble_codec)
      size <- size + this.repeatedBool_.CalculateSize(TestAllTypes._repeated_repeatedBool_codec)
      size <- size + this.repeatedString_.CalculateSize(TestAllTypes._repeated_repeatedString_codec)
      size <- size + this.repeatedBytes_.CalculateSize(TestAllTypes._repeated_repeatedBytes_codec)
      size <- size + this.repeatedNestedMessage_.CalculateSize(TestAllTypes._repeated_repeatedNestedMessage_codec)
      size <- size + this.repeatedForeignMessage_.CalculateSize(TestAllTypes._repeated_repeatedForeignMessage_codec)
      size <- size + this.repeatedImportMessage_.CalculateSize(TestAllTypes._repeated_repeatedImportMessage_codec)
      size <- size + this.repeatedNestedEnum_.CalculateSize(TestAllTypes._repeated_repeatedNestedEnum_codec)
      size <- size + this.repeatedForeignEnum_.CalculateSize(TestAllTypes._repeated_repeatedForeignEnum_codec)
      size <- size + this.repeatedImportEnum_.CalculateSize(TestAllTypes._repeated_repeatedImportEnum_codec)
      size <- size + this.repeatedPublicImportMessage_.CalculateSize(TestAllTypes._repeated_repeatedPublicImportMessage_codec)
      match this.OneofField with
      | TestAllTypes_OneofField.OneofUint32 x ->
        size <- size + 2 + CodedOutputStream.ComputeUInt32Size(x)
      | TestAllTypes_OneofField.OneofNestedMessage x -> size <-size + 2 + CodedOutputStream.ComputeMessageSize(x)
      | TestAllTypes_OneofField.OneofString x ->
        size <- size + 2 + CodedOutputStream.ComputeStringSize(x)
      | TestAllTypes_OneofField.OneofBytes x ->
        size <- size + 2 + CodedOutputStream.ComputeBytesSize(x)
      | _ -> ()
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: TestAllTypes) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        if other.SingleInt32 <> 0 then
          this.SingleInt32 <- other.SingleInt32
        if other.SingleInt64 <> 0L then
          this.SingleInt64 <- other.SingleInt64
        if other.SingleUint32 <> 0u then
          this.SingleUint32 <- other.SingleUint32
        if other.SingleUint64 <> 0UL then
          this.SingleUint64 <- other.SingleUint64
        if other.SingleSint32 <> 0 then
          this.SingleSint32 <- other.SingleSint32
        if other.SingleSint64 <> 0L then
          this.SingleSint64 <- other.SingleSint64
        if other.SingleFixed32 <> 0u then
          this.SingleFixed32 <- other.SingleFixed32
        if other.SingleFixed64 <> 0UL then
          this.SingleFixed64 <- other.SingleFixed64
        if other.SingleSfixed32 <> 0 then
          this.SingleSfixed32 <- other.SingleSfixed32
        if other.SingleSfixed64 <> 0L then
          this.SingleSfixed64 <- other.SingleSfixed64
        if other.SingleFloat <> 0.0f then
          this.SingleFloat <- other.SingleFloat
        if other.SingleDouble <> 0.0 then
          this.SingleDouble <- other.SingleDouble
        if other.SingleBool <> false then
          this.SingleBool <- other.SingleBool
        if other.SingleString.Length <> 0 then
          this.SingleString <- other.SingleString
        if other.SingleBytes.Length <> 0 then
          this.SingleBytes <- other.SingleBytes
        if other.singleNestedMessage_ <> null then
          if this.singleNestedMessage_ = null then
            this.singleNestedMessage_ <- new TestAllTypes_NestedMessage()
          (this.SingleNestedMessage :> IMessage<_>).MergeFrom(other.SingleNestedMessage)
        if other.singleForeignMessage_ <> null then
          if this.singleForeignMessage_ = null then
            this.singleForeignMessage_ <- new ForeignMessage()
          (this.SingleForeignMessage :> IMessage<_>).MergeFrom(other.SingleForeignMessage)
        if other.singleImportMessage_ <> null then
          if this.singleImportMessage_ = null then
            this.singleImportMessage_ <- new ProtobufUnittestImport.ImportMessage()
          (this.SingleImportMessage :> IMessage<_>).MergeFrom(other.SingleImportMessage)
        if other.SingleNestedEnum <> enum 0 then
          this.SingleNestedEnum <- other.SingleNestedEnum
        if other.SingleForeignEnum <> enum 0 then
          this.SingleForeignEnum <- other.SingleForeignEnum
        if other.SingleImportEnum <> enum 0 then
          this.SingleImportEnum <- other.SingleImportEnum
        if other.singlePublicImportMessage_ <> null then
          if this.singlePublicImportMessage_ = null then
            this.singlePublicImportMessage_ <- new ProtobufUnittestImport.PublicImportMessage()
          (this.SinglePublicImportMessage :> IMessage<_>).MergeFrom(other.SinglePublicImportMessage)
        this.repeatedInt32_.Add(other.repeatedInt32_)
        this.repeatedInt64_.Add(other.repeatedInt64_)
        this.repeatedUint32_.Add(other.repeatedUint32_)
        this.repeatedUint64_.Add(other.repeatedUint64_)
        this.repeatedSint32_.Add(other.repeatedSint32_)
        this.repeatedSint64_.Add(other.repeatedSint64_)
        this.repeatedFixed32_.Add(other.repeatedFixed32_)
        this.repeatedFixed64_.Add(other.repeatedFixed64_)
        this.repeatedSfixed32_.Add(other.repeatedSfixed32_)
        this.repeatedSfixed64_.Add(other.repeatedSfixed64_)
        this.repeatedFloat_.Add(other.repeatedFloat_)
        this.repeatedDouble_.Add(other.repeatedDouble_)
        this.repeatedBool_.Add(other.repeatedBool_)
        this.repeatedString_.Add(other.repeatedString_)
        this.repeatedBytes_.Add(other.repeatedBytes_)
        this.repeatedNestedMessage_.Add(other.repeatedNestedMessage_)
        this.repeatedForeignMessage_.Add(other.repeatedForeignMessage_)
        this.repeatedImportMessage_.Add(other.repeatedImportMessage_)
        this.repeatedNestedEnum_.Add(other.repeatedNestedEnum_)
        this.repeatedForeignEnum_.Add(other.repeatedForeignEnum_)
        this.repeatedImportEnum_.Add(other.repeatedImportEnum_)
        this.repeatedPublicImportMessage_.Add(other.repeatedPublicImportMessage_)
        this.OneofField <-
          match other.OneofField with
          | TestAllTypes_OneofField.OneofUint32 x -> TestAllTypes_OneofField.OneofUint32 x
          | TestAllTypes_OneofField.OneofNestedMessage x ->
            match this.OneofField with
            | TestAllTypes_OneofField.OneofNestedMessage y ->
              (y :> IMessage<_>).MergeFrom(x)
              TestAllTypes_OneofField.OneofNestedMessage y
            | _ ->
              let y = new TestAllTypes_NestedMessage()
              (y :> IMessage<_>).MergeFrom(x)
              TestAllTypes_OneofField.OneofNestedMessage y
          | TestAllTypes_OneofField.OneofString x -> TestAllTypes_OneofField.OneofString x
          | TestAllTypes_OneofField.OneofBytes x -> TestAllTypes_OneofField.OneofBytes x
          | _ -> TestAllTypes_OneofField.OneofNone

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 8u ->
            this.SingleInt32 <- input.ReadInt32()
          | 16u ->
            this.SingleInt64 <- input.ReadInt64()
          | 24u ->
            this.SingleUint32 <- input.ReadUInt32()
          | 32u ->
            this.SingleUint64 <- input.ReadUInt64()
          | 40u ->
            this.SingleSint32 <- input.ReadSInt32()
          | 48u ->
            this.SingleSint64 <- input.ReadSInt64()
          | 61u ->
            this.SingleFixed32 <- input.ReadFixed32()
          | 65u ->
            this.SingleFixed64 <- input.ReadFixed64()
          | 77u ->
            this.SingleSfixed32 <- input.ReadSFixed32()
          | 81u ->
            this.SingleSfixed64 <- input.ReadSFixed64()
          | 93u ->
            this.SingleFloat <- input.ReadFloat()
          | 97u ->
            this.SingleDouble <- input.ReadDouble()
          | 104u ->
            this.SingleBool <- input.ReadBool()
          | 114u ->
            this.SingleString <- input.ReadString()
          | 122u ->
            this.SingleBytes <- input.ReadBytes()
          | 146u ->
            if this.singleNestedMessage_ = null then
              this.singleNestedMessage_ <- new TestAllTypes_NestedMessage()
            input.ReadMessage(this.singleNestedMessage_)
          | 154u ->
            if this.singleForeignMessage_ = null then
              this.singleForeignMessage_ <- new ForeignMessage()
            input.ReadMessage(this.singleForeignMessage_)
          | 162u ->
            if this.singleImportMessage_ = null then
              this.singleImportMessage_ <- new ProtobufUnittestImport.ImportMessage()
            input.ReadMessage(this.singleImportMessage_)
          | 168u ->
            this.singleNestedEnum_ <- enum(input.ReadEnum())
          | 176u ->
            this.singleForeignEnum_ <- enum(input.ReadEnum())
          | 184u ->
            this.singleImportEnum_ <- enum(input.ReadEnum())
          | 210u ->
            if this.singlePublicImportMessage_ = null then
              this.singlePublicImportMessage_ <- new ProtobufUnittestImport.PublicImportMessage()
            input.ReadMessage(this.singlePublicImportMessage_)
          | 250u
          | 248u ->
            this.repeatedInt32_.AddEntriesFrom(input, TestAllTypes._repeated_repeatedInt32_codec)
          | 258u
          | 256u ->
            this.repeatedInt64_.AddEntriesFrom(input, TestAllTypes._repeated_repeatedInt64_codec)
          | 266u
          | 264u ->
            this.repeatedUint32_.AddEntriesFrom(input, TestAllTypes._repeated_repeatedUint32_codec)
          | 274u
          | 272u ->
            this.repeatedUint64_.AddEntriesFrom(input, TestAllTypes._repeated_repeatedUint64_codec)
          | 282u
          | 280u ->
            this.repeatedSint32_.AddEntriesFrom(input, TestAllTypes._repeated_repeatedSint32_codec)
          | 290u
          | 288u ->
            this.repeatedSint64_.AddEntriesFrom(input, TestAllTypes._repeated_repeatedSint64_codec)
          | 298u
          | 301u ->
            this.repeatedFixed32_.AddEntriesFrom(input, TestAllTypes._repeated_repeatedFixed32_codec)
          | 306u
          | 305u ->
            this.repeatedFixed64_.AddEntriesFrom(input, TestAllTypes._repeated_repeatedFixed64_codec)
          | 314u
          | 317u ->
            this.repeatedSfixed32_.AddEntriesFrom(input, TestAllTypes._repeated_repeatedSfixed32_codec)
          | 322u
          | 321u ->
            this.repeatedSfixed64_.AddEntriesFrom(input, TestAllTypes._repeated_repeatedSfixed64_codec)
          | 330u
          | 333u ->
            this.repeatedFloat_.AddEntriesFrom(input, TestAllTypes._repeated_repeatedFloat_codec)
          | 338u
          | 337u ->
            this.repeatedDouble_.AddEntriesFrom(input, TestAllTypes._repeated_repeatedDouble_codec)
          | 346u
          | 344u ->
            this.repeatedBool_.AddEntriesFrom(input, TestAllTypes._repeated_repeatedBool_codec)
          | 354u ->
            this.repeatedString_.AddEntriesFrom(input, TestAllTypes._repeated_repeatedString_codec)
          | 362u ->
            this.repeatedBytes_.AddEntriesFrom(input, TestAllTypes._repeated_repeatedBytes_codec)
          | 386u ->
            this.repeatedNestedMessage_.AddEntriesFrom(input, TestAllTypes._repeated_repeatedNestedMessage_codec)
          | 394u ->
            this.repeatedForeignMessage_.AddEntriesFrom(input, TestAllTypes._repeated_repeatedForeignMessage_codec)
          | 402u ->
            this.repeatedImportMessage_.AddEntriesFrom(input, TestAllTypes._repeated_repeatedImportMessage_codec)
          | 410u
          | 408u ->
            this.repeatedNestedEnum_.AddEntriesFrom(input, TestAllTypes._repeated_repeatedNestedEnum_codec)
          | 418u
          | 416u ->
            this.repeatedForeignEnum_.AddEntriesFrom(input, TestAllTypes._repeated_repeatedForeignEnum_codec)
          | 426u
          | 424u ->
            this.repeatedImportEnum_.AddEntriesFrom(input, TestAllTypes._repeated_repeatedImportEnum_codec)
          | 434u ->
            this.repeatedPublicImportMessage_.AddEntriesFrom(input, TestAllTypes._repeated_repeatedPublicImportMessage_codec)
          | 888u ->
            this.OneofField <- TestAllTypes_OneofField.OneofUint32 (input.ReadUInt32())
          | 898u ->
            let subBuilder = new TestAllTypes_NestedMessage()
            match this.OneofField with
            | TestAllTypes_OneofField.OneofNestedMessage x ->
              (subBuilder :> IMessage<_>).MergeFrom(x)
            | _ -> ()
            input.ReadMessage(subBuilder)
            this.OneofField <- TestAllTypes_OneofField.OneofNestedMessage subBuilder
          | 906u ->
            this.OneofField <- TestAllTypes_OneofField.OneofString (input.ReadString())
          | 914u ->
            this.OneofField <- TestAllTypes_OneofField.OneofBytes (input.ReadBytes())
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : TestAllTypes =
      new TestAllTypes(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: TestAllTypes) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if this.SingleInt32 <> other.SingleInt32 then false
      else if this.SingleInt64 <> other.SingleInt64 then false
      else if this.SingleUint32 <> other.SingleUint32 then false
      else if this.SingleUint64 <> other.SingleUint64 then false
      else if this.SingleSint32 <> other.SingleSint32 then false
      else if this.SingleSint64 <> other.SingleSint64 then false
      else if this.SingleFixed32 <> other.SingleFixed32 then false
      else if this.SingleFixed64 <> other.SingleFixed64 then false
      else if this.SingleSfixed32 <> other.SingleSfixed32 then false
      else if this.SingleSfixed64 <> other.SingleSfixed64 then false
      else if this.SingleFloat <> other.SingleFloat then false
      else if this.SingleDouble <> other.SingleDouble then false
      else if this.SingleBool <> other.SingleBool then false
      else if this.SingleString <> other.SingleString then false
      else if this.SingleBytes <> other.SingleBytes then false
      else if not (System.Object.Equals(this.SingleNestedMessage, other.SingleNestedMessage)) then false
      else if not (System.Object.Equals(this.SingleForeignMessage, other.SingleForeignMessage)) then false
      else if not (System.Object.Equals(this.SingleImportMessage, other.SingleImportMessage)) then false
      else if this.SingleNestedEnum <> other.SingleNestedEnum then false
      else if this.SingleForeignEnum <> other.SingleForeignEnum then false
      else if this.SingleImportEnum <> other.SingleImportEnum then false
      else if not (System.Object.Equals(this.SinglePublicImportMessage, other.SinglePublicImportMessage)) then false
      else if not (this.repeatedInt32_.Equals(other.repeatedInt32_)) then false
      else if not (this.repeatedInt64_.Equals(other.repeatedInt64_)) then false
      else if not (this.repeatedUint32_.Equals(other.repeatedUint32_)) then false
      else if not (this.repeatedUint64_.Equals(other.repeatedUint64_)) then false
      else if not (this.repeatedSint32_.Equals(other.repeatedSint32_)) then false
      else if not (this.repeatedSint64_.Equals(other.repeatedSint64_)) then false
      else if not (this.repeatedFixed32_.Equals(other.repeatedFixed32_)) then false
      else if not (this.repeatedFixed64_.Equals(other.repeatedFixed64_)) then false
      else if not (this.repeatedSfixed32_.Equals(other.repeatedSfixed32_)) then false
      else if not (this.repeatedSfixed64_.Equals(other.repeatedSfixed64_)) then false
      else if not (this.repeatedFloat_.Equals(other.repeatedFloat_)) then false
      else if not (this.repeatedDouble_.Equals(other.repeatedDouble_)) then false
      else if not (this.repeatedBool_.Equals(other.repeatedBool_)) then false
      else if not (this.repeatedString_.Equals(other.repeatedString_)) then false
      else if not (this.repeatedBytes_.Equals(other.repeatedBytes_)) then false
      else if not (this.repeatedNestedMessage_.Equals(other.repeatedNestedMessage_)) then false
      else if not (this.repeatedForeignMessage_.Equals(other.repeatedForeignMessage_)) then false
      else if not (this.repeatedImportMessage_.Equals(other.repeatedImportMessage_)) then false
      else if not (this.repeatedNestedEnum_.Equals(other.repeatedNestedEnum_)) then false
      else if not (this.repeatedForeignEnum_.Equals(other.repeatedForeignEnum_)) then false
      else if not (this.repeatedImportEnum_.Equals(other.repeatedImportEnum_)) then false
      else if not (this.repeatedPublicImportMessage_.Equals(other.repeatedPublicImportMessage_)) then false
      else if not (this.OneofField = other.OneofField) then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = TestAllTypes.Descriptor

//#region Nested types
/// <summary>Container for nested types declared in the TestAllTypes message type.</summary>
and public TestAllTypes_NestedEnum =
  | [<OriginalName("NESTED_ENUM_UNSPECIFIED")>] Unspecified = 0
  | [<OriginalName("FOO")>] Foo = 1
  | [<OriginalName("BAR")>] Bar = 2
  | [<OriginalName("BAZ")>] Baz = 3
  /// <summary>
  /// Intentionally negative.
  /// </summary>
  | [<OriginalName("NEG")>] Neg = -1

and [<AllowNullLiteral>] public TestAllTypes_NestedMessage =
  val mutable private bb_ : int

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      bb_ = Unchecked.defaultof<int>
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: TestAllTypes_NestedMessage) =
    {
      bb_ = other.bb_
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<TestAllTypes_NestedMessage>(fun () -> new TestAllTypes_NestedMessage())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = TestAllTypes.Descriptor.NestedTypes.[0]

  /// <summary>Field number for the "bb" field.</summary>
  static member public BbFieldNumber = 1
  /// <summary>
  /// The field name "b" fails to compile in proto1 because it conflicts with
  /// a local variable named "b" in one of the generated methods.  Doh.
  /// This file needs to compile in proto1 to test backwards-compatibility.
  /// </summary>
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.Bb
    with get() = this.bb_
    and set(value: int) =
      this.bb_ <- value


  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? TestAllTypes_NestedMessage as x -> (x :> System.IEquatable<TestAllTypes_NestedMessage>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    if this.Bb <> 0 then hash <- hash ^^^ this.Bb.GetHashCode()
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<TestAllTypes_NestedMessage> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      if this.Bb <> 0 then
        output.WriteRawTag(8uy)
        output.WriteInt32(this.Bb)


    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      if this.Bb <> 0 then
        size <- size + 1 + CodedOutputStream.ComputeInt32Size(this.Bb)
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: TestAllTypes_NestedMessage) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        if other.Bb <> 0 then
          this.Bb <- other.Bb

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 8u ->
            this.Bb <- input.ReadInt32()
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : TestAllTypes_NestedMessage =
      new TestAllTypes_NestedMessage(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: TestAllTypes_NestedMessage) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if this.Bb <> other.Bb then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = TestAllTypes_NestedMessage.Descriptor

//#endregion nested for nested types in the TestAllTypes

/// <summary>
/// This proto includes a recusively nested message.
/// </summary>
and [<AllowNullLiteral>] public NestedTestAllTypes =
  val mutable private child_ : NestedTestAllTypes
  val mutable private payload_ : TestAllTypes
  val mutable private repeatedChild_ : RepeatedField<NestedTestAllTypes>

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      child_ = null
      payload_ = null
      repeatedChild_ = new RepeatedField<NestedTestAllTypes>()
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: NestedTestAllTypes) =
    {
      child_ = if other.child_ <> null then (other.child_ :> IDeepCloneable<_>).Clone() else null
      payload_ = if other.payload_ <> null then (other.payload_ :> IDeepCloneable<_>).Clone() else null
      repeatedChild_ = other.repeatedChild_.Clone()
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<NestedTestAllTypes>(fun () -> new NestedTestAllTypes())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[1]

  /// <summary>Field number for the "child" field.</summary>
  static member public ChildFieldNumber = 1
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.Child
    with get () = this.child_
    and set(value: NestedTestAllTypes) =
      this.child_ <- value

  /// <summary>Field number for the "payload" field.</summary>
  static member public PayloadFieldNumber = 2
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.Payload
    with get () = this.payload_
    and set(value: TestAllTypes) =
      this.payload_ <- value

  /// <summary>Field number for the "repeated_child" field.</summary>
  static member public RepeatedChildFieldNumber = 3
  static member private _repeated_repeatedChild_codec =
    FieldCodec.ForMessage(26u, NestedTestAllTypes.Parser)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedChild
    with get() = this.repeatedChild_

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? NestedTestAllTypes as x -> (x :> System.IEquatable<NestedTestAllTypes>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    if this.child_ <> null then hash <- hash ^^^ this.Child.GetHashCode()
    if this.payload_ <> null then hash <- hash ^^^ this.Payload.GetHashCode()
    hash <- hash ^^^ this.repeatedChild_.GetHashCode()
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<NestedTestAllTypes> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      if this.child_ <> null then
        output.WriteRawTag(10uy)
        output.WriteMessage(this.Child)
      if this.payload_ <> null then
        output.WriteRawTag(18uy)
        output.WriteMessage(this.Payload)
      this.repeatedChild_.WriteTo(output, NestedTestAllTypes._repeated_repeatedChild_codec)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      if this.child_ <> null then
        size <- size + 1 + CodedOutputStream.ComputeMessageSize(this.Child)
      if this.payload_ <> null then
        size <- size + 1 + CodedOutputStream.ComputeMessageSize(this.Payload)
      size <- size + this.repeatedChild_.CalculateSize(NestedTestAllTypes._repeated_repeatedChild_codec)
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: NestedTestAllTypes) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        if other.child_ <> null then
          if this.child_ = null then
            this.child_ <- new NestedTestAllTypes()
          (this.Child :> IMessage<_>).MergeFrom(other.Child)
        if other.payload_ <> null then
          if this.payload_ = null then
            this.payload_ <- new TestAllTypes()
          (this.Payload :> IMessage<_>).MergeFrom(other.Payload)
        this.repeatedChild_.Add(other.repeatedChild_)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 10u ->
            if this.child_ = null then
              this.child_ <- new NestedTestAllTypes()
            input.ReadMessage(this.child_)
          | 18u ->
            if this.payload_ = null then
              this.payload_ <- new TestAllTypes()
            input.ReadMessage(this.payload_)
          | 26u ->
            this.repeatedChild_.AddEntriesFrom(input, NestedTestAllTypes._repeated_repeatedChild_codec)
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : NestedTestAllTypes =
      new NestedTestAllTypes(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: NestedTestAllTypes) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if not (System.Object.Equals(this.Child, other.Child)) then false
      else if not (System.Object.Equals(this.Payload, other.Payload)) then false
      else if not (this.repeatedChild_.Equals(other.repeatedChild_)) then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = NestedTestAllTypes.Descriptor

and [<AllowNullLiteral>] public TestDeprecatedFields =
  val mutable private deprecatedInt32_ : int

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      deprecatedInt32_ = Unchecked.defaultof<int>
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: TestDeprecatedFields) =
    {
      deprecatedInt32_ = other.deprecatedInt32_
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<TestDeprecatedFields>(fun () -> new TestDeprecatedFields())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[2]

  /// <summary>Field number for the "deprecated_int32" field.</summary>
  static member public DeprecatedInt32FieldNumber = 1
  [<System.ObsoleteAttribute>]
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.DeprecatedInt32
    with get() = this.deprecatedInt32_
    and set(value: int) =
      this.deprecatedInt32_ <- value


  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? TestDeprecatedFields as x -> (x :> System.IEquatable<TestDeprecatedFields>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    if this.DeprecatedInt32 <> 0 then hash <- hash ^^^ this.DeprecatedInt32.GetHashCode()
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<TestDeprecatedFields> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      if this.DeprecatedInt32 <> 0 then
        output.WriteRawTag(8uy)
        output.WriteInt32(this.DeprecatedInt32)


    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      if this.DeprecatedInt32 <> 0 then
        size <- size + 1 + CodedOutputStream.ComputeInt32Size(this.DeprecatedInt32)
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: TestDeprecatedFields) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        if other.DeprecatedInt32 <> 0 then
          this.DeprecatedInt32 <- other.DeprecatedInt32

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 8u ->
            this.DeprecatedInt32 <- input.ReadInt32()
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : TestDeprecatedFields =
      new TestDeprecatedFields(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: TestDeprecatedFields) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if this.DeprecatedInt32 <> other.DeprecatedInt32 then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = TestDeprecatedFields.Descriptor

/// <summary>
/// Define these after TestAllTypes to make sure the compiler can handle
/// that.
/// </summary>
and [<AllowNullLiteral>] public ForeignMessage =
  val mutable private c_ : int

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      c_ = Unchecked.defaultof<int>
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: ForeignMessage) =
    {
      c_ = other.c_
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<ForeignMessage>(fun () -> new ForeignMessage())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[3]

  /// <summary>Field number for the "c" field.</summary>
  static member public CFieldNumber = 1
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.C
    with get() = this.c_
    and set(value: int) =
      this.c_ <- value


  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? ForeignMessage as x -> (x :> System.IEquatable<ForeignMessage>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    if this.C <> 0 then hash <- hash ^^^ this.C.GetHashCode()
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<ForeignMessage> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      if this.C <> 0 then
        output.WriteRawTag(8uy)
        output.WriteInt32(this.C)


    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      if this.C <> 0 then
        size <- size + 1 + CodedOutputStream.ComputeInt32Size(this.C)
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: ForeignMessage) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        if other.C <> 0 then
          this.C <- other.C

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 8u ->
            this.C <- input.ReadInt32()
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : ForeignMessage =
      new ForeignMessage(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: ForeignMessage) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if this.C <> other.C then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = ForeignMessage.Descriptor

and [<AllowNullLiteral>] public TestReservedFields =

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: TestReservedFields) =
    {
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<TestReservedFields>(fun () -> new TestReservedFields())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[4]

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? TestReservedFields as x -> (x :> System.IEquatable<TestReservedFields>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<TestReservedFields> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      ()
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: TestReservedFields) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        ()
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : TestReservedFields =
      new TestReservedFields(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: TestReservedFields) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else true

    member this.Descriptor : Reflection.MessageDescriptor = TestReservedFields.Descriptor

/// <summary>
/// Test that we can use NestedMessage from outside TestAllTypes.
/// </summary>
and [<AllowNullLiteral>] public TestForeignNested =
  val mutable private foreignNested_ : TestAllTypes_NestedMessage

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      foreignNested_ = null
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: TestForeignNested) =
    {
      foreignNested_ = if other.foreignNested_ <> null then (other.foreignNested_ :> IDeepCloneable<_>).Clone() else null
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<TestForeignNested>(fun () -> new TestForeignNested())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[5]

  /// <summary>Field number for the "foreign_nested" field.</summary>
  static member public ForeignNestedFieldNumber = 1
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.ForeignNested
    with get () = this.foreignNested_
    and set(value: TestAllTypes_NestedMessage) =
      this.foreignNested_ <- value

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? TestForeignNested as x -> (x :> System.IEquatable<TestForeignNested>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    if this.foreignNested_ <> null then hash <- hash ^^^ this.ForeignNested.GetHashCode()
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<TestForeignNested> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      if this.foreignNested_ <> null then
        output.WriteRawTag(10uy)
        output.WriteMessage(this.ForeignNested)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      if this.foreignNested_ <> null then
        size <- size + 1 + CodedOutputStream.ComputeMessageSize(this.ForeignNested)
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: TestForeignNested) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        if other.foreignNested_ <> null then
          if this.foreignNested_ = null then
            this.foreignNested_ <- new TestAllTypes_NestedMessage()
          (this.ForeignNested :> IMessage<_>).MergeFrom(other.ForeignNested)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 10u ->
            if this.foreignNested_ = null then
              this.foreignNested_ <- new TestAllTypes_NestedMessage()
            input.ReadMessage(this.foreignNested_)
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : TestForeignNested =
      new TestForeignNested(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: TestForeignNested) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if not (System.Object.Equals(this.ForeignNested, other.ForeignNested)) then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = TestForeignNested.Descriptor

/// <summary>
/// Test that really large tag numbers don't break anything.
/// </summary>
and [<AllowNullLiteral>] public TestReallyLargeTagNumber =
  val mutable private a_ : int
  val mutable private bb_ : int

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      a_ = Unchecked.defaultof<int>
      bb_ = Unchecked.defaultof<int>
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: TestReallyLargeTagNumber) =
    {
      a_ = other.a_
      bb_ = other.bb_
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<TestReallyLargeTagNumber>(fun () -> new TestReallyLargeTagNumber())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[6]

  /// <summary>Field number for the "a" field.</summary>
  static member public AFieldNumber = 1
  /// <summary>
  /// The largest possible tag number is 2^28 - 1, since the wire format uses
  /// three bits to communicate wire type.
  /// </summary>
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.A
    with get() = this.a_
    and set(value: int) =
      this.a_ <- value


  /// <summary>Field number for the "bb" field.</summary>
  static member public BbFieldNumber = 268435455
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.Bb
    with get() = this.bb_
    and set(value: int) =
      this.bb_ <- value


  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? TestReallyLargeTagNumber as x -> (x :> System.IEquatable<TestReallyLargeTagNumber>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    if this.A <> 0 then hash <- hash ^^^ this.A.GetHashCode()
    if this.Bb <> 0 then hash <- hash ^^^ this.Bb.GetHashCode()
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<TestReallyLargeTagNumber> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      if this.A <> 0 then
        output.WriteRawTag(8uy)
        output.WriteInt32(this.A)

      if this.Bb <> 0 then
        output.WriteRawTag(248uy, 255uy, 255uy, 255uy, 7uy)
        output.WriteInt32(this.Bb)


    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      if this.A <> 0 then
        size <- size + 1 + CodedOutputStream.ComputeInt32Size(this.A)
      if this.Bb <> 0 then
        size <- size + 5 + CodedOutputStream.ComputeInt32Size(this.Bb)
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: TestReallyLargeTagNumber) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        if other.A <> 0 then
          this.A <- other.A
        if other.Bb <> 0 then
          this.Bb <- other.Bb

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 8u ->
            this.A <- input.ReadInt32()
          | 2147483640u ->
            this.Bb <- input.ReadInt32()
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : TestReallyLargeTagNumber =
      new TestReallyLargeTagNumber(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: TestReallyLargeTagNumber) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if this.A <> other.A then false
      else if this.Bb <> other.Bb then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = TestReallyLargeTagNumber.Descriptor

and [<AllowNullLiteral>] public TestRecursiveMessage =
  val mutable private a_ : TestRecursiveMessage
  val mutable private i_ : int

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      a_ = null
      i_ = Unchecked.defaultof<int>
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: TestRecursiveMessage) =
    {
      a_ = if other.a_ <> null then (other.a_ :> IDeepCloneable<_>).Clone() else null
      i_ = other.i_
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<TestRecursiveMessage>(fun () -> new TestRecursiveMessage())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[7]

  /// <summary>Field number for the "a" field.</summary>
  static member public AFieldNumber = 1
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.A
    with get () = this.a_
    and set(value: TestRecursiveMessage) =
      this.a_ <- value

  /// <summary>Field number for the "i" field.</summary>
  static member public IFieldNumber = 2
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.I
    with get() = this.i_
    and set(value: int) =
      this.i_ <- value


  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? TestRecursiveMessage as x -> (x :> System.IEquatable<TestRecursiveMessage>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    if this.a_ <> null then hash <- hash ^^^ this.A.GetHashCode()
    if this.I <> 0 then hash <- hash ^^^ this.I.GetHashCode()
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<TestRecursiveMessage> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      if this.a_ <> null then
        output.WriteRawTag(10uy)
        output.WriteMessage(this.A)
      if this.I <> 0 then
        output.WriteRawTag(16uy)
        output.WriteInt32(this.I)


    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      if this.a_ <> null then
        size <- size + 1 + CodedOutputStream.ComputeMessageSize(this.A)
      if this.I <> 0 then
        size <- size + 1 + CodedOutputStream.ComputeInt32Size(this.I)
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: TestRecursiveMessage) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        if other.a_ <> null then
          if this.a_ = null then
            this.a_ <- new TestRecursiveMessage()
          (this.A :> IMessage<_>).MergeFrom(other.A)
        if other.I <> 0 then
          this.I <- other.I

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 10u ->
            if this.a_ = null then
              this.a_ <- new TestRecursiveMessage()
            input.ReadMessage(this.a_)
          | 16u ->
            this.I <- input.ReadInt32()
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : TestRecursiveMessage =
      new TestRecursiveMessage(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: TestRecursiveMessage) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if not (System.Object.Equals(this.A, other.A)) then false
      else if this.I <> other.I then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = TestRecursiveMessage.Descriptor

/// <summary>
/// Test that mutual recursion works.
/// </summary>
and [<AllowNullLiteral>] public TestMutualRecursionA =
  val mutable private bb_ : TestMutualRecursionB

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      bb_ = null
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: TestMutualRecursionA) =
    {
      bb_ = if other.bb_ <> null then (other.bb_ :> IDeepCloneable<_>).Clone() else null
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<TestMutualRecursionA>(fun () -> new TestMutualRecursionA())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[8]

  /// <summary>Field number for the "bb" field.</summary>
  static member public BbFieldNumber = 1
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.Bb
    with get () = this.bb_
    and set(value: TestMutualRecursionB) =
      this.bb_ <- value

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? TestMutualRecursionA as x -> (x :> System.IEquatable<TestMutualRecursionA>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    if this.bb_ <> null then hash <- hash ^^^ this.Bb.GetHashCode()
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<TestMutualRecursionA> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      if this.bb_ <> null then
        output.WriteRawTag(10uy)
        output.WriteMessage(this.Bb)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      if this.bb_ <> null then
        size <- size + 1 + CodedOutputStream.ComputeMessageSize(this.Bb)
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: TestMutualRecursionA) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        if other.bb_ <> null then
          if this.bb_ = null then
            this.bb_ <- new TestMutualRecursionB()
          (this.Bb :> IMessage<_>).MergeFrom(other.Bb)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 10u ->
            if this.bb_ = null then
              this.bb_ <- new TestMutualRecursionB()
            input.ReadMessage(this.bb_)
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : TestMutualRecursionA =
      new TestMutualRecursionA(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: TestMutualRecursionA) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if not (System.Object.Equals(this.Bb, other.Bb)) then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = TestMutualRecursionA.Descriptor

and [<AllowNullLiteral>] public TestMutualRecursionB =
  val mutable private a_ : TestMutualRecursionA
  val mutable private optionalInt32_ : int

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      a_ = null
      optionalInt32_ = Unchecked.defaultof<int>
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: TestMutualRecursionB) =
    {
      a_ = if other.a_ <> null then (other.a_ :> IDeepCloneable<_>).Clone() else null
      optionalInt32_ = other.optionalInt32_
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<TestMutualRecursionB>(fun () -> new TestMutualRecursionB())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[9]

  /// <summary>Field number for the "a" field.</summary>
  static member public AFieldNumber = 1
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.A
    with get () = this.a_
    and set(value: TestMutualRecursionA) =
      this.a_ <- value

  /// <summary>Field number for the "optional_int32" field.</summary>
  static member public OptionalInt32FieldNumber = 2
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.OptionalInt32
    with get() = this.optionalInt32_
    and set(value: int) =
      this.optionalInt32_ <- value


  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? TestMutualRecursionB as x -> (x :> System.IEquatable<TestMutualRecursionB>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    if this.a_ <> null then hash <- hash ^^^ this.A.GetHashCode()
    if this.OptionalInt32 <> 0 then hash <- hash ^^^ this.OptionalInt32.GetHashCode()
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<TestMutualRecursionB> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      if this.a_ <> null then
        output.WriteRawTag(10uy)
        output.WriteMessage(this.A)
      if this.OptionalInt32 <> 0 then
        output.WriteRawTag(16uy)
        output.WriteInt32(this.OptionalInt32)


    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      if this.a_ <> null then
        size <- size + 1 + CodedOutputStream.ComputeMessageSize(this.A)
      if this.OptionalInt32 <> 0 then
        size <- size + 1 + CodedOutputStream.ComputeInt32Size(this.OptionalInt32)
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: TestMutualRecursionB) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        if other.a_ <> null then
          if this.a_ = null then
            this.a_ <- new TestMutualRecursionA()
          (this.A :> IMessage<_>).MergeFrom(other.A)
        if other.OptionalInt32 <> 0 then
          this.OptionalInt32 <- other.OptionalInt32

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 10u ->
            if this.a_ = null then
              this.a_ <- new TestMutualRecursionA()
            input.ReadMessage(this.a_)
          | 16u ->
            this.OptionalInt32 <- input.ReadInt32()
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : TestMutualRecursionB =
      new TestMutualRecursionB(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: TestMutualRecursionB) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if not (System.Object.Equals(this.A, other.A)) then false
      else if this.OptionalInt32 <> other.OptionalInt32 then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = TestMutualRecursionB.Descriptor

and [<AllowNullLiteral>] public TestEnumAllowAlias =
  val mutable private value_ : TestEnumWithDupValue

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      value_ = enum 0
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: TestEnumAllowAlias) =
    {
      value_ = other.value_
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<TestEnumAllowAlias>(fun () -> new TestEnumAllowAlias())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[10]

  /// <summary>Field number for the "value" field.</summary>
  static member public ValueFieldNumber = 1
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.Value
    with get() = this.value_
    and set(value: TestEnumWithDupValue) =
      this.value_ <- value


  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? TestEnumAllowAlias as x -> (x :> System.IEquatable<TestEnumAllowAlias>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    if this.Value <> enum 0 then hash <- hash ^^^ this.Value.GetHashCode()
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<TestEnumAllowAlias> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      if this.Value <> enum 0 then
        output.WriteRawTag(8uy)
        output.WriteEnum(int this.Value)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      if this.Value <> enum 0 then
        size <- size + 1 + CodedOutputStream.ComputeEnumSize(int this.Value)
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: TestEnumAllowAlias) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        if other.Value <> enum 0 then
          this.Value <- other.Value

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 8u ->
            this.value_ <- enum(input.ReadEnum())
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : TestEnumAllowAlias =
      new TestEnumAllowAlias(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: TestEnumAllowAlias) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if this.Value <> other.Value then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = TestEnumAllowAlias.Descriptor

/// <summary>
/// Test message with CamelCase field names.  This violates Protocol Buffer
/// standard style.
/// </summary>
and [<AllowNullLiteral>] public TestCamelCaseFieldNames =
  val mutable private primitiveField_ : int
  val mutable private stringField_ : string
  val mutable private enumField_ : ForeignEnum
  val mutable private messageField_ : ForeignMessage
  val mutable private repeatedPrimitiveField_ : RepeatedField<int>
  val mutable private repeatedStringField_ : RepeatedField<string>
  val mutable private repeatedEnumField_ : RepeatedField<ForeignEnum>
  val mutable private repeatedMessageField_ : RepeatedField<ForeignMessage>

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      primitiveField_ = Unchecked.defaultof<int>
      stringField_ = ""
      enumField_ = enum 0
      messageField_ = null
      repeatedPrimitiveField_ = new RepeatedField<int>()
      repeatedStringField_ = new RepeatedField<string>()
      repeatedEnumField_ = new RepeatedField<ForeignEnum>()
      repeatedMessageField_ = new RepeatedField<ForeignMessage>()
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: TestCamelCaseFieldNames) =
    {
      primitiveField_ = other.primitiveField_
      stringField_ = other.stringField_
      enumField_ = other.enumField_
      messageField_ = if other.messageField_ <> null then (other.messageField_ :> IDeepCloneable<_>).Clone() else null
      repeatedPrimitiveField_ = other.repeatedPrimitiveField_.Clone()
      repeatedStringField_ = other.repeatedStringField_.Clone()
      repeatedEnumField_ = other.repeatedEnumField_.Clone()
      repeatedMessageField_ = other.repeatedMessageField_.Clone()
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<TestCamelCaseFieldNames>(fun () -> new TestCamelCaseFieldNames())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[11]

  /// <summary>Field number for the "PrimitiveField" field.</summary>
  static member public PrimitiveFieldFieldNumber = 1
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.PrimitiveField
    with get() = this.primitiveField_
    and set(value: int) =
      this.primitiveField_ <- value


  /// <summary>Field number for the "StringField" field.</summary>
  static member public StringFieldFieldNumber = 2
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.StringField
    with get() = this.stringField_
    and set(value: string) =
      if value <> null then
        this.stringField_ <- value


  /// <summary>Field number for the "EnumField" field.</summary>
  static member public EnumFieldFieldNumber = 3
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.EnumField
    with get() = this.enumField_
    and set(value: ForeignEnum) =
      this.enumField_ <- value


  /// <summary>Field number for the "MessageField" field.</summary>
  static member public MessageFieldFieldNumber = 4
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.MessageField
    with get () = this.messageField_
    and set(value: ForeignMessage) =
      this.messageField_ <- value

  /// <summary>Field number for the "RepeatedPrimitiveField" field.</summary>
  static member public RepeatedPrimitiveFieldFieldNumber = 7
  static member private _repeated_repeatedPrimitiveField_codec =
    FieldCodec.ForInt32(58u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedPrimitiveField
    with get() = this.repeatedPrimitiveField_

  /// <summary>Field number for the "RepeatedStringField" field.</summary>
  static member public RepeatedStringFieldFieldNumber = 8
  static member private _repeated_repeatedStringField_codec =
    FieldCodec.ForString(66u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedStringField
    with get() = this.repeatedStringField_

  /// <summary>Field number for the "RepeatedEnumField" field.</summary>
  static member public RepeatedEnumFieldFieldNumber = 9
  static member private _repeated_repeatedEnumField_codec =
    FieldCodec.ForEnum(74u, (fun x -> int x), (fun x -> enum x))
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedEnumField
    with get() = this.repeatedEnumField_

  /// <summary>Field number for the "RepeatedMessageField" field.</summary>
  static member public RepeatedMessageFieldFieldNumber = 10
  static member private _repeated_repeatedMessageField_codec =
    FieldCodec.ForMessage(82u, ForeignMessage.Parser)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedMessageField
    with get() = this.repeatedMessageField_

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? TestCamelCaseFieldNames as x -> (x :> System.IEquatable<TestCamelCaseFieldNames>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    if this.PrimitiveField <> 0 then hash <- hash ^^^ this.PrimitiveField.GetHashCode()
    if this.StringField.Length <> 0 then hash <- hash ^^^ this.StringField.GetHashCode()
    if this.EnumField <> enum 0 then hash <- hash ^^^ this.EnumField.GetHashCode()
    if this.messageField_ <> null then hash <- hash ^^^ this.MessageField.GetHashCode()
    hash <- hash ^^^ this.repeatedPrimitiveField_.GetHashCode()
    hash <- hash ^^^ this.repeatedStringField_.GetHashCode()
    hash <- hash ^^^ this.repeatedEnumField_.GetHashCode()
    hash <- hash ^^^ this.repeatedMessageField_.GetHashCode()
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<TestCamelCaseFieldNames> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      if this.PrimitiveField <> 0 then
        output.WriteRawTag(8uy)
        output.WriteInt32(this.PrimitiveField)

      if this.StringField.Length <> 0 then
        output.WriteRawTag(18uy)
        output.WriteString(this.StringField)

      if this.EnumField <> enum 0 then
        output.WriteRawTag(24uy)
        output.WriteEnum(int this.EnumField)
      if this.messageField_ <> null then
        output.WriteRawTag(34uy)
        output.WriteMessage(this.MessageField)
      this.repeatedPrimitiveField_.WriteTo(output, TestCamelCaseFieldNames._repeated_repeatedPrimitiveField_codec)
      this.repeatedStringField_.WriteTo(output, TestCamelCaseFieldNames._repeated_repeatedStringField_codec)
      this.repeatedEnumField_.WriteTo(output, TestCamelCaseFieldNames._repeated_repeatedEnumField_codec)
      this.repeatedMessageField_.WriteTo(output, TestCamelCaseFieldNames._repeated_repeatedMessageField_codec)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      if this.PrimitiveField <> 0 then
        size <- size + 1 + CodedOutputStream.ComputeInt32Size(this.PrimitiveField)
      if this.StringField.Length <> 0 then
        size <- size + 1 + CodedOutputStream.ComputeStringSize(this.StringField)
      if this.EnumField <> enum 0 then
        size <- size + 1 + CodedOutputStream.ComputeEnumSize(int this.EnumField)
      if this.messageField_ <> null then
        size <- size + 1 + CodedOutputStream.ComputeMessageSize(this.MessageField)
      size <- size + this.repeatedPrimitiveField_.CalculateSize(TestCamelCaseFieldNames._repeated_repeatedPrimitiveField_codec)
      size <- size + this.repeatedStringField_.CalculateSize(TestCamelCaseFieldNames._repeated_repeatedStringField_codec)
      size <- size + this.repeatedEnumField_.CalculateSize(TestCamelCaseFieldNames._repeated_repeatedEnumField_codec)
      size <- size + this.repeatedMessageField_.CalculateSize(TestCamelCaseFieldNames._repeated_repeatedMessageField_codec)
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: TestCamelCaseFieldNames) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        if other.PrimitiveField <> 0 then
          this.PrimitiveField <- other.PrimitiveField
        if other.StringField.Length <> 0 then
          this.StringField <- other.StringField
        if other.EnumField <> enum 0 then
          this.EnumField <- other.EnumField
        if other.messageField_ <> null then
          if this.messageField_ = null then
            this.messageField_ <- new ForeignMessage()
          (this.MessageField :> IMessage<_>).MergeFrom(other.MessageField)
        this.repeatedPrimitiveField_.Add(other.repeatedPrimitiveField_)
        this.repeatedStringField_.Add(other.repeatedStringField_)
        this.repeatedEnumField_.Add(other.repeatedEnumField_)
        this.repeatedMessageField_.Add(other.repeatedMessageField_)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 8u ->
            this.PrimitiveField <- input.ReadInt32()
          | 18u ->
            this.StringField <- input.ReadString()
          | 24u ->
            this.enumField_ <- enum(input.ReadEnum())
          | 34u ->
            if this.messageField_ = null then
              this.messageField_ <- new ForeignMessage()
            input.ReadMessage(this.messageField_)
          | 58u
          | 56u ->
            this.repeatedPrimitiveField_.AddEntriesFrom(input, TestCamelCaseFieldNames._repeated_repeatedPrimitiveField_codec)
          | 66u ->
            this.repeatedStringField_.AddEntriesFrom(input, TestCamelCaseFieldNames._repeated_repeatedStringField_codec)
          | 74u
          | 72u ->
            this.repeatedEnumField_.AddEntriesFrom(input, TestCamelCaseFieldNames._repeated_repeatedEnumField_codec)
          | 82u ->
            this.repeatedMessageField_.AddEntriesFrom(input, TestCamelCaseFieldNames._repeated_repeatedMessageField_codec)
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : TestCamelCaseFieldNames =
      new TestCamelCaseFieldNames(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: TestCamelCaseFieldNames) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if this.PrimitiveField <> other.PrimitiveField then false
      else if this.StringField <> other.StringField then false
      else if this.EnumField <> other.EnumField then false
      else if not (System.Object.Equals(this.MessageField, other.MessageField)) then false
      else if not (this.repeatedPrimitiveField_.Equals(other.repeatedPrimitiveField_)) then false
      else if not (this.repeatedStringField_.Equals(other.repeatedStringField_)) then false
      else if not (this.repeatedEnumField_.Equals(other.repeatedEnumField_)) then false
      else if not (this.repeatedMessageField_.Equals(other.repeatedMessageField_)) then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = TestCamelCaseFieldNames.Descriptor

/// <summary>
/// We list fields out of order, to ensure that we're using field number and not
/// field index to determine serialization order.
/// </summary>
and [<AllowNullLiteral>] public TestFieldOrderings =
  val mutable private myString_ : string
  val mutable private myInt_ : int64
  val mutable private myFloat_ : single
  val mutable private singleNestedMessage_ : TestFieldOrderings_NestedMessage

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      myString_ = ""
      myInt_ = Unchecked.defaultof<int64>
      myFloat_ = Unchecked.defaultof<single>
      singleNestedMessage_ = null
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: TestFieldOrderings) =
    {
      myString_ = other.myString_
      myInt_ = other.myInt_
      myFloat_ = other.myFloat_
      singleNestedMessage_ = if other.singleNestedMessage_ <> null then (other.singleNestedMessage_ :> IDeepCloneable<_>).Clone() else null
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<TestFieldOrderings>(fun () -> new TestFieldOrderings())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[12]

  /// <summary>Field number for the "my_string" field.</summary>
  static member public MyStringFieldNumber = 11
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.MyString
    with get() = this.myString_
    and set(value: string) =
      if value <> null then
        this.myString_ <- value


  /// <summary>Field number for the "my_int" field.</summary>
  static member public MyIntFieldNumber = 1
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.MyInt
    with get() = this.myInt_
    and set(value: int64) =
      this.myInt_ <- value


  /// <summary>Field number for the "my_float" field.</summary>
  static member public MyFloatFieldNumber = 101
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.MyFloat
    with get() = this.myFloat_
    and set(value: single) =
      this.myFloat_ <- value


  /// <summary>Field number for the "single_nested_message" field.</summary>
  static member public SingleNestedMessageFieldNumber = 200
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.SingleNestedMessage
    with get () = this.singleNestedMessage_
    and set(value: TestFieldOrderings_NestedMessage) =
      this.singleNestedMessage_ <- value

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? TestFieldOrderings as x -> (x :> System.IEquatable<TestFieldOrderings>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    if this.MyString.Length <> 0 then hash <- hash ^^^ this.MyString.GetHashCode()
    if this.MyInt <> 0L then hash <- hash ^^^ this.MyInt.GetHashCode()
    if this.MyFloat <> 0.0f then hash <- hash ^^^ this.MyFloat.GetHashCode()
    if this.singleNestedMessage_ <> null then hash <- hash ^^^ this.SingleNestedMessage.GetHashCode()
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<TestFieldOrderings> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      if this.MyString.Length <> 0 then
        output.WriteRawTag(90uy)
        output.WriteString(this.MyString)

      if this.MyInt <> 0L then
        output.WriteRawTag(8uy)
        output.WriteInt64(this.MyInt)

      if this.MyFloat <> 0.0f then
        output.WriteRawTag(173uy, 6uy)
        output.WriteFloat(this.MyFloat)

      if this.singleNestedMessage_ <> null then
        output.WriteRawTag(194uy, 12uy)
        output.WriteMessage(this.SingleNestedMessage)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      if this.MyString.Length <> 0 then
        size <- size + 1 + CodedOutputStream.ComputeStringSize(this.MyString)
      if this.MyInt <> 0L then
        size <- size + 1 + CodedOutputStream.ComputeInt64Size(this.MyInt)
      if this.MyFloat <> 0.0f then
        size <- size + 2 + 4
      if this.singleNestedMessage_ <> null then
        size <- size + 2 + CodedOutputStream.ComputeMessageSize(this.SingleNestedMessage)
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: TestFieldOrderings) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        if other.MyString.Length <> 0 then
          this.MyString <- other.MyString
        if other.MyInt <> 0L then
          this.MyInt <- other.MyInt
        if other.MyFloat <> 0.0f then
          this.MyFloat <- other.MyFloat
        if other.singleNestedMessage_ <> null then
          if this.singleNestedMessage_ = null then
            this.singleNestedMessage_ <- new TestFieldOrderings_NestedMessage()
          (this.SingleNestedMessage :> IMessage<_>).MergeFrom(other.SingleNestedMessage)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 8u ->
            this.MyString <- input.ReadString()
          | 90u ->
            this.MyInt <- input.ReadInt64()
          | 813u ->
            this.MyFloat <- input.ReadFloat()
          | 1602u ->
            if this.singleNestedMessage_ = null then
              this.singleNestedMessage_ <- new TestFieldOrderings_NestedMessage()
            input.ReadMessage(this.singleNestedMessage_)
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : TestFieldOrderings =
      new TestFieldOrderings(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: TestFieldOrderings) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if this.MyString <> other.MyString then false
      else if this.MyInt <> other.MyInt then false
      else if this.MyFloat <> other.MyFloat then false
      else if not (System.Object.Equals(this.SingleNestedMessage, other.SingleNestedMessage)) then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = TestFieldOrderings.Descriptor

//#region Nested types
/// <summary>Container for nested types declared in the TestFieldOrderings message type.</summary>
and [<AllowNullLiteral>] public TestFieldOrderings_NestedMessage =
  val mutable private oo_ : int64
  val mutable private bb_ : int

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      oo_ = Unchecked.defaultof<int64>
      bb_ = Unchecked.defaultof<int>
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: TestFieldOrderings_NestedMessage) =
    {
      oo_ = other.oo_
      bb_ = other.bb_
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<TestFieldOrderings_NestedMessage>(fun () -> new TestFieldOrderings_NestedMessage())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = TestFieldOrderings.Descriptor.NestedTypes.[0]

  /// <summary>Field number for the "oo" field.</summary>
  static member public OoFieldNumber = 2
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.Oo
    with get() = this.oo_
    and set(value: int64) =
      this.oo_ <- value


  /// <summary>Field number for the "bb" field.</summary>
  static member public BbFieldNumber = 1
  /// <summary>
  /// The field name "b" fails to compile in proto1 because it conflicts with
  /// a local variable named "b" in one of the generated methods.  Doh.
  /// This file needs to compile in proto1 to test backwards-compatibility.
  /// </summary>
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.Bb
    with get() = this.bb_
    and set(value: int) =
      this.bb_ <- value


  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? TestFieldOrderings_NestedMessage as x -> (x :> System.IEquatable<TestFieldOrderings_NestedMessage>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    if this.Oo <> 0L then hash <- hash ^^^ this.Oo.GetHashCode()
    if this.Bb <> 0 then hash <- hash ^^^ this.Bb.GetHashCode()
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<TestFieldOrderings_NestedMessage> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      if this.Oo <> 0L then
        output.WriteRawTag(16uy)
        output.WriteInt64(this.Oo)

      if this.Bb <> 0 then
        output.WriteRawTag(8uy)
        output.WriteInt32(this.Bb)


    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      if this.Oo <> 0L then
        size <- size + 1 + CodedOutputStream.ComputeInt64Size(this.Oo)
      if this.Bb <> 0 then
        size <- size + 1 + CodedOutputStream.ComputeInt32Size(this.Bb)
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: TestFieldOrderings_NestedMessage) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        if other.Oo <> 0L then
          this.Oo <- other.Oo
        if other.Bb <> 0 then
          this.Bb <- other.Bb

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 8u ->
            this.Oo <- input.ReadInt64()
          | 16u ->
            this.Bb <- input.ReadInt32()
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : TestFieldOrderings_NestedMessage =
      new TestFieldOrderings_NestedMessage(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: TestFieldOrderings_NestedMessage) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if this.Oo <> other.Oo then false
      else if this.Bb <> other.Bb then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = TestFieldOrderings_NestedMessage.Descriptor

//#endregion nested for nested types in the TestFieldOrderings

and [<AllowNullLiteral>] public SparseEnumMessage =
  val mutable private sparseEnum_ : TestSparseEnum

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      sparseEnum_ = enum 0
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: SparseEnumMessage) =
    {
      sparseEnum_ = other.sparseEnum_
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<SparseEnumMessage>(fun () -> new SparseEnumMessage())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[13]

  /// <summary>Field number for the "sparse_enum" field.</summary>
  static member public SparseEnumFieldNumber = 1
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.SparseEnum
    with get() = this.sparseEnum_
    and set(value: TestSparseEnum) =
      this.sparseEnum_ <- value


  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? SparseEnumMessage as x -> (x :> System.IEquatable<SparseEnumMessage>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    if this.SparseEnum <> enum 0 then hash <- hash ^^^ this.SparseEnum.GetHashCode()
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<SparseEnumMessage> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      if this.SparseEnum <> enum 0 then
        output.WriteRawTag(8uy)
        output.WriteEnum(int this.SparseEnum)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      if this.SparseEnum <> enum 0 then
        size <- size + 1 + CodedOutputStream.ComputeEnumSize(int this.SparseEnum)
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: SparseEnumMessage) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        if other.SparseEnum <> enum 0 then
          this.SparseEnum <- other.SparseEnum

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 8u ->
            this.sparseEnum_ <- enum(input.ReadEnum())
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : SparseEnumMessage =
      new SparseEnumMessage(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: SparseEnumMessage) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if this.SparseEnum <> other.SparseEnum then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = SparseEnumMessage.Descriptor

/// <summary>
/// Test String and Bytes: string is for valid UTF-8 strings
/// </summary>
and [<AllowNullLiteral>] public OneString =
  val mutable private data_ : string

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      data_ = ""
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: OneString) =
    {
      data_ = other.data_
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<OneString>(fun () -> new OneString())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[14]

  /// <summary>Field number for the "data" field.</summary>
  static member public DataFieldNumber = 1
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.Data
    with get() = this.data_
    and set(value: string) =
      if value <> null then
        this.data_ <- value


  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? OneString as x -> (x :> System.IEquatable<OneString>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    if this.Data.Length <> 0 then hash <- hash ^^^ this.Data.GetHashCode()
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<OneString> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      if this.Data.Length <> 0 then
        output.WriteRawTag(10uy)
        output.WriteString(this.Data)


    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      if this.Data.Length <> 0 then
        size <- size + 1 + CodedOutputStream.ComputeStringSize(this.Data)
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: OneString) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        if other.Data.Length <> 0 then
          this.Data <- other.Data

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 10u ->
            this.Data <- input.ReadString()
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : OneString =
      new OneString(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: OneString) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if this.Data <> other.Data then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = OneString.Descriptor

and [<AllowNullLiteral>] public MoreString =
  val mutable private data_ : RepeatedField<string>

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      data_ = new RepeatedField<string>()
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: MoreString) =
    {
      data_ = other.data_.Clone()
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<MoreString>(fun () -> new MoreString())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[15]

  /// <summary>Field number for the "data" field.</summary>
  static member public DataFieldNumber = 1
  static member private _repeated_data_codec =
    FieldCodec.ForString(10u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.Data
    with get() = this.data_

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? MoreString as x -> (x :> System.IEquatable<MoreString>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    hash <- hash ^^^ this.data_.GetHashCode()
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<MoreString> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      this.data_.WriteTo(output, MoreString._repeated_data_codec)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      size <- size + this.data_.CalculateSize(MoreString._repeated_data_codec)
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: MoreString) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        this.data_.Add(other.data_)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 10u ->
            this.data_.AddEntriesFrom(input, MoreString._repeated_data_codec)
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : MoreString =
      new MoreString(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: MoreString) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if not (this.data_.Equals(other.data_)) then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = MoreString.Descriptor

and [<AllowNullLiteral>] public OneBytes =
  val mutable private data_ : ByteString

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      data_ = ByteString.Empty
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: OneBytes) =
    {
      data_ = other.data_
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<OneBytes>(fun () -> new OneBytes())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[16]

  /// <summary>Field number for the "data" field.</summary>
  static member public DataFieldNumber = 1
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.Data
    with get() = this.data_
    and set(value: ByteString) =
      if value <> null then
        this.data_ <- value


  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? OneBytes as x -> (x :> System.IEquatable<OneBytes>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    if this.Data.Length <> 0 then hash <- hash ^^^ this.Data.GetHashCode()
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<OneBytes> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      if this.Data.Length <> 0 then
        output.WriteRawTag(10uy)
        output.WriteBytes(this.Data)


    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      if this.Data.Length <> 0 then
        size <- size + 1 + CodedOutputStream.ComputeBytesSize(this.Data)
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: OneBytes) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        if other.Data.Length <> 0 then
          this.Data <- other.Data

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 10u ->
            this.Data <- input.ReadBytes()
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : OneBytes =
      new OneBytes(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: OneBytes) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if this.Data <> other.Data then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = OneBytes.Descriptor

and [<AllowNullLiteral>] public MoreBytes =
  val mutable private data_ : ByteString

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      data_ = ByteString.Empty
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: MoreBytes) =
    {
      data_ = other.data_
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<MoreBytes>(fun () -> new MoreBytes())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[17]

  /// <summary>Field number for the "data" field.</summary>
  static member public DataFieldNumber = 1
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.Data
    with get() = this.data_
    and set(value: ByteString) =
      if value <> null then
        this.data_ <- value


  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? MoreBytes as x -> (x :> System.IEquatable<MoreBytes>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    if this.Data.Length <> 0 then hash <- hash ^^^ this.Data.GetHashCode()
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<MoreBytes> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      if this.Data.Length <> 0 then
        output.WriteRawTag(10uy)
        output.WriteBytes(this.Data)


    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      if this.Data.Length <> 0 then
        size <- size + 1 + CodedOutputStream.ComputeBytesSize(this.Data)
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: MoreBytes) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        if other.Data.Length <> 0 then
          this.Data <- other.Data

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 10u ->
            this.Data <- input.ReadBytes()
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : MoreBytes =
      new MoreBytes(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: MoreBytes) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if this.Data <> other.Data then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = MoreBytes.Descriptor

/// <summary>
/// Test int32, uint32, int64, uint64, and bool are all compatible
/// </summary>
and [<AllowNullLiteral>] public Int32Message =
  val mutable private data_ : int

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      data_ = Unchecked.defaultof<int>
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: Int32Message) =
    {
      data_ = other.data_
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<Int32Message>(fun () -> new Int32Message())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[18]

  /// <summary>Field number for the "data" field.</summary>
  static member public DataFieldNumber = 1
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.Data
    with get() = this.data_
    and set(value: int) =
      this.data_ <- value


  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? Int32Message as x -> (x :> System.IEquatable<Int32Message>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    if this.Data <> 0 then hash <- hash ^^^ this.Data.GetHashCode()
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<Int32Message> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      if this.Data <> 0 then
        output.WriteRawTag(8uy)
        output.WriteInt32(this.Data)


    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      if this.Data <> 0 then
        size <- size + 1 + CodedOutputStream.ComputeInt32Size(this.Data)
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: Int32Message) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        if other.Data <> 0 then
          this.Data <- other.Data

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 8u ->
            this.Data <- input.ReadInt32()
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : Int32Message =
      new Int32Message(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: Int32Message) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if this.Data <> other.Data then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = Int32Message.Descriptor

and [<AllowNullLiteral>] public Uint32Message =
  val mutable private data_ : uint32

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      data_ = Unchecked.defaultof<uint32>
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: Uint32Message) =
    {
      data_ = other.data_
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<Uint32Message>(fun () -> new Uint32Message())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[19]

  /// <summary>Field number for the "data" field.</summary>
  static member public DataFieldNumber = 1
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.Data
    with get() = this.data_
    and set(value: uint32) =
      this.data_ <- value


  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? Uint32Message as x -> (x :> System.IEquatable<Uint32Message>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    if this.Data <> 0u then hash <- hash ^^^ this.Data.GetHashCode()
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<Uint32Message> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      if this.Data <> 0u then
        output.WriteRawTag(8uy)
        output.WriteUInt32(this.Data)


    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      if this.Data <> 0u then
        size <- size + 1 + CodedOutputStream.ComputeUInt32Size(this.Data)
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: Uint32Message) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        if other.Data <> 0u then
          this.Data <- other.Data

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 8u ->
            this.Data <- input.ReadUInt32()
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : Uint32Message =
      new Uint32Message(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: Uint32Message) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if this.Data <> other.Data then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = Uint32Message.Descriptor

and [<AllowNullLiteral>] public Int64Message =
  val mutable private data_ : int64

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      data_ = Unchecked.defaultof<int64>
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: Int64Message) =
    {
      data_ = other.data_
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<Int64Message>(fun () -> new Int64Message())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[20]

  /// <summary>Field number for the "data" field.</summary>
  static member public DataFieldNumber = 1
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.Data
    with get() = this.data_
    and set(value: int64) =
      this.data_ <- value


  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? Int64Message as x -> (x :> System.IEquatable<Int64Message>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    if this.Data <> 0L then hash <- hash ^^^ this.Data.GetHashCode()
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<Int64Message> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      if this.Data <> 0L then
        output.WriteRawTag(8uy)
        output.WriteInt64(this.Data)


    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      if this.Data <> 0L then
        size <- size + 1 + CodedOutputStream.ComputeInt64Size(this.Data)
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: Int64Message) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        if other.Data <> 0L then
          this.Data <- other.Data

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 8u ->
            this.Data <- input.ReadInt64()
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : Int64Message =
      new Int64Message(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: Int64Message) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if this.Data <> other.Data then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = Int64Message.Descriptor

and [<AllowNullLiteral>] public Uint64Message =
  val mutable private data_ : uint64

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      data_ = Unchecked.defaultof<uint64>
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: Uint64Message) =
    {
      data_ = other.data_
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<Uint64Message>(fun () -> new Uint64Message())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[21]

  /// <summary>Field number for the "data" field.</summary>
  static member public DataFieldNumber = 1
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.Data
    with get() = this.data_
    and set(value: uint64) =
      this.data_ <- value


  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? Uint64Message as x -> (x :> System.IEquatable<Uint64Message>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    if this.Data <> 0UL then hash <- hash ^^^ this.Data.GetHashCode()
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<Uint64Message> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      if this.Data <> 0UL then
        output.WriteRawTag(8uy)
        output.WriteUInt64(this.Data)


    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      if this.Data <> 0UL then
        size <- size + 1 + CodedOutputStream.ComputeUInt64Size(this.Data)
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: Uint64Message) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        if other.Data <> 0UL then
          this.Data <- other.Data

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 8u ->
            this.Data <- input.ReadUInt64()
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : Uint64Message =
      new Uint64Message(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: Uint64Message) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if this.Data <> other.Data then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = Uint64Message.Descriptor

and [<AllowNullLiteral>] public BoolMessage =
  val mutable private data_ : bool

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      data_ = Unchecked.defaultof<bool>
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: BoolMessage) =
    {
      data_ = other.data_
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<BoolMessage>(fun () -> new BoolMessage())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[22]

  /// <summary>Field number for the "data" field.</summary>
  static member public DataFieldNumber = 1
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.Data
    with get() = this.data_
    and set(value: bool) =
      this.data_ <- value


  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? BoolMessage as x -> (x :> System.IEquatable<BoolMessage>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    if this.Data <> false then hash <- hash ^^^ this.Data.GetHashCode()
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<BoolMessage> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      if this.Data <> false then
        output.WriteRawTag(8uy)
        output.WriteBool(this.Data)


    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      if this.Data <> false then
        size <- size + 1 + 1
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: BoolMessage) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        if other.Data <> false then
          this.Data <- other.Data

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 8u ->
            this.Data <- input.ReadBool()
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : BoolMessage =
      new BoolMessage(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: BoolMessage) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if this.Data <> other.Data then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = BoolMessage.Descriptor

and TestOneof_Foo =
  | OneofNone
  | FooInt of int
  | FooString of string
  | FooMessage of TestAllTypes

/// <summary>
/// Test oneofs.
/// </summary>
and [<AllowNullLiteral>] public TestOneof =
  val mutable private foo_ : TestOneof_Foo

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      foo_ = TestOneof_Foo.OneofNone
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: TestOneof) =
    {
      foo_ =
        match other.foo_ with
        | TestOneof_Foo.FooInt x -> TestOneof_Foo.FooInt x
        | TestOneof_Foo.FooString x -> TestOneof_Foo.FooString x
        | TestOneof_Foo.FooMessage x -> TestOneof_Foo.FooMessage ((x :> IDeepCloneable<_>).Clone())
        | TestOneof_Foo.OneofNone -> TestOneof_Foo.OneofNone
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<TestOneof>(fun () -> new TestOneof())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[23]

  /// <summary>Field number for the "foo_int" field.</summary>
  static member public FooIntFieldNumber = 1

  /// <summary>Field number for the "foo_string" field.</summary>
  static member public FooStringFieldNumber = 2

  /// <summary>Field number for the "foo_message" field.</summary>
  static member public FooMessageFieldNumber = 3

  member public this.Foo
    with get () = this.foo_
    and set(value: TestOneof_Foo) =
      this.foo_ <- value

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? TestOneof as x -> (x :> System.IEquatable<TestOneof>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    match this.Foo with
    | TestOneof_Foo.OneofNone -> ()
    | TestOneof_Foo.FooInt x -> hash <- hash ^^^ x.GetHashCode() ^^^ 1
    | TestOneof_Foo.FooString x -> hash <- hash ^^^ x.GetHashCode() ^^^ 2
    | TestOneof_Foo.FooMessage x -> hash <- hash ^^^ x.GetHashCode() ^^^ 3
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<TestOneof> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      match this.foo_ with
        | TestOneof_Foo.FooInt x ->
          output.WriteRawTag(8uy)
          output.WriteInt32(x)
        | _ -> ()

      match this.foo_ with
        | TestOneof_Foo.FooString x ->
          output.WriteRawTag(18uy)
          output.WriteString(x)
        | _ -> ()

      match this.foo_ with
        | TestOneof_Foo.FooMessage x ->
          output.WriteRawTag(26uy)
          output.WriteMessage(x)
        | _ -> ()


    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      match this.Foo with
      | TestOneof_Foo.FooInt x ->
        size <- size + 1 + CodedOutputStream.ComputeInt32Size(x)
      | TestOneof_Foo.FooString x ->
        size <- size + 1 + CodedOutputStream.ComputeStringSize(x)
      | TestOneof_Foo.FooMessage x -> size <-size + 1 + CodedOutputStream.ComputeMessageSize(x)
      | _ -> ()
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: TestOneof) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        this.Foo <-
          match other.Foo with
          | TestOneof_Foo.FooInt x -> TestOneof_Foo.FooInt x
          | TestOneof_Foo.FooString x -> TestOneof_Foo.FooString x
          | TestOneof_Foo.FooMessage x ->
            match this.Foo with
            | TestOneof_Foo.FooMessage y ->
              (y :> IMessage<_>).MergeFrom(x)
              TestOneof_Foo.FooMessage y
            | _ ->
              let y = new TestAllTypes()
              (y :> IMessage<_>).MergeFrom(x)
              TestOneof_Foo.FooMessage y
          | _ -> TestOneof_Foo.OneofNone

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 8u ->
            this.Foo <- TestOneof_Foo.FooInt (input.ReadInt32())
          | 18u ->
            this.Foo <- TestOneof_Foo.FooString (input.ReadString())
          | 26u ->
            let subBuilder = new TestAllTypes()
            match this.Foo with
            | TestOneof_Foo.FooMessage x ->
              (subBuilder :> IMessage<_>).MergeFrom(x)
            | _ -> ()
            input.ReadMessage(subBuilder)
            this.Foo <- TestOneof_Foo.FooMessage subBuilder
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : TestOneof =
      new TestOneof(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: TestOneof) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if not (this.Foo = other.Foo) then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = TestOneof.Descriptor

and [<AllowNullLiteral>] public TestPackedTypes =
  val mutable private packedInt32_ : RepeatedField<int>
  val mutable private packedInt64_ : RepeatedField<int64>
  val mutable private packedUint32_ : RepeatedField<uint32>
  val mutable private packedUint64_ : RepeatedField<uint64>
  val mutable private packedSint32_ : RepeatedField<int>
  val mutable private packedSint64_ : RepeatedField<int64>
  val mutable private packedFixed32_ : RepeatedField<uint32>
  val mutable private packedFixed64_ : RepeatedField<uint64>
  val mutable private packedSfixed32_ : RepeatedField<int>
  val mutable private packedSfixed64_ : RepeatedField<int64>
  val mutable private packedFloat_ : RepeatedField<single>
  val mutable private packedDouble_ : RepeatedField<double>
  val mutable private packedBool_ : RepeatedField<bool>
  val mutable private packedEnum_ : RepeatedField<ForeignEnum>

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      packedInt32_ = new RepeatedField<int>()
      packedInt64_ = new RepeatedField<int64>()
      packedUint32_ = new RepeatedField<uint32>()
      packedUint64_ = new RepeatedField<uint64>()
      packedSint32_ = new RepeatedField<int>()
      packedSint64_ = new RepeatedField<int64>()
      packedFixed32_ = new RepeatedField<uint32>()
      packedFixed64_ = new RepeatedField<uint64>()
      packedSfixed32_ = new RepeatedField<int>()
      packedSfixed64_ = new RepeatedField<int64>()
      packedFloat_ = new RepeatedField<single>()
      packedDouble_ = new RepeatedField<double>()
      packedBool_ = new RepeatedField<bool>()
      packedEnum_ = new RepeatedField<ForeignEnum>()
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: TestPackedTypes) =
    {
      packedInt32_ = other.packedInt32_.Clone()
      packedInt64_ = other.packedInt64_.Clone()
      packedUint32_ = other.packedUint32_.Clone()
      packedUint64_ = other.packedUint64_.Clone()
      packedSint32_ = other.packedSint32_.Clone()
      packedSint64_ = other.packedSint64_.Clone()
      packedFixed32_ = other.packedFixed32_.Clone()
      packedFixed64_ = other.packedFixed64_.Clone()
      packedSfixed32_ = other.packedSfixed32_.Clone()
      packedSfixed64_ = other.packedSfixed64_.Clone()
      packedFloat_ = other.packedFloat_.Clone()
      packedDouble_ = other.packedDouble_.Clone()
      packedBool_ = other.packedBool_.Clone()
      packedEnum_ = other.packedEnum_.Clone()
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<TestPackedTypes>(fun () -> new TestPackedTypes())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[24]

  /// <summary>Field number for the "packed_int32" field.</summary>
  static member public PackedInt32FieldNumber = 90
  static member private _repeated_packedInt32_codec =
    FieldCodec.ForInt32(722u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.PackedInt32
    with get() = this.packedInt32_

  /// <summary>Field number for the "packed_int64" field.</summary>
  static member public PackedInt64FieldNumber = 91
  static member private _repeated_packedInt64_codec =
    FieldCodec.ForInt64(730u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.PackedInt64
    with get() = this.packedInt64_

  /// <summary>Field number for the "packed_uint32" field.</summary>
  static member public PackedUint32FieldNumber = 92
  static member private _repeated_packedUint32_codec =
    FieldCodec.ForUInt32(738u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.PackedUint32
    with get() = this.packedUint32_

  /// <summary>Field number for the "packed_uint64" field.</summary>
  static member public PackedUint64FieldNumber = 93
  static member private _repeated_packedUint64_codec =
    FieldCodec.ForUInt64(746u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.PackedUint64
    with get() = this.packedUint64_

  /// <summary>Field number for the "packed_sint32" field.</summary>
  static member public PackedSint32FieldNumber = 94
  static member private _repeated_packedSint32_codec =
    FieldCodec.ForSInt32(754u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.PackedSint32
    with get() = this.packedSint32_

  /// <summary>Field number for the "packed_sint64" field.</summary>
  static member public PackedSint64FieldNumber = 95
  static member private _repeated_packedSint64_codec =
    FieldCodec.ForSInt64(762u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.PackedSint64
    with get() = this.packedSint64_

  /// <summary>Field number for the "packed_fixed32" field.</summary>
  static member public PackedFixed32FieldNumber = 96
  static member private _repeated_packedFixed32_codec =
    FieldCodec.ForFixed32(770u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.PackedFixed32
    with get() = this.packedFixed32_

  /// <summary>Field number for the "packed_fixed64" field.</summary>
  static member public PackedFixed64FieldNumber = 97
  static member private _repeated_packedFixed64_codec =
    FieldCodec.ForFixed64(778u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.PackedFixed64
    with get() = this.packedFixed64_

  /// <summary>Field number for the "packed_sfixed32" field.</summary>
  static member public PackedSfixed32FieldNumber = 98
  static member private _repeated_packedSfixed32_codec =
    FieldCodec.ForSFixed32(786u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.PackedSfixed32
    with get() = this.packedSfixed32_

  /// <summary>Field number for the "packed_sfixed64" field.</summary>
  static member public PackedSfixed64FieldNumber = 99
  static member private _repeated_packedSfixed64_codec =
    FieldCodec.ForSFixed64(794u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.PackedSfixed64
    with get() = this.packedSfixed64_

  /// <summary>Field number for the "packed_float" field.</summary>
  static member public PackedFloatFieldNumber = 100
  static member private _repeated_packedFloat_codec =
    FieldCodec.ForFloat(802u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.PackedFloat
    with get() = this.packedFloat_

  /// <summary>Field number for the "packed_double" field.</summary>
  static member public PackedDoubleFieldNumber = 101
  static member private _repeated_packedDouble_codec =
    FieldCodec.ForDouble(810u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.PackedDouble
    with get() = this.packedDouble_

  /// <summary>Field number for the "packed_bool" field.</summary>
  static member public PackedBoolFieldNumber = 102
  static member private _repeated_packedBool_codec =
    FieldCodec.ForBool(818u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.PackedBool
    with get() = this.packedBool_

  /// <summary>Field number for the "packed_enum" field.</summary>
  static member public PackedEnumFieldNumber = 103
  static member private _repeated_packedEnum_codec =
    FieldCodec.ForEnum(826u, (fun x -> int x), (fun x -> enum x))
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.PackedEnum
    with get() = this.packedEnum_

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? TestPackedTypes as x -> (x :> System.IEquatable<TestPackedTypes>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    hash <- hash ^^^ this.packedInt32_.GetHashCode()
    hash <- hash ^^^ this.packedInt64_.GetHashCode()
    hash <- hash ^^^ this.packedUint32_.GetHashCode()
    hash <- hash ^^^ this.packedUint64_.GetHashCode()
    hash <- hash ^^^ this.packedSint32_.GetHashCode()
    hash <- hash ^^^ this.packedSint64_.GetHashCode()
    hash <- hash ^^^ this.packedFixed32_.GetHashCode()
    hash <- hash ^^^ this.packedFixed64_.GetHashCode()
    hash <- hash ^^^ this.packedSfixed32_.GetHashCode()
    hash <- hash ^^^ this.packedSfixed64_.GetHashCode()
    hash <- hash ^^^ this.packedFloat_.GetHashCode()
    hash <- hash ^^^ this.packedDouble_.GetHashCode()
    hash <- hash ^^^ this.packedBool_.GetHashCode()
    hash <- hash ^^^ this.packedEnum_.GetHashCode()
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<TestPackedTypes> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      this.packedInt32_.WriteTo(output, TestPackedTypes._repeated_packedInt32_codec)
      this.packedInt64_.WriteTo(output, TestPackedTypes._repeated_packedInt64_codec)
      this.packedUint32_.WriteTo(output, TestPackedTypes._repeated_packedUint32_codec)
      this.packedUint64_.WriteTo(output, TestPackedTypes._repeated_packedUint64_codec)
      this.packedSint32_.WriteTo(output, TestPackedTypes._repeated_packedSint32_codec)
      this.packedSint64_.WriteTo(output, TestPackedTypes._repeated_packedSint64_codec)
      this.packedFixed32_.WriteTo(output, TestPackedTypes._repeated_packedFixed32_codec)
      this.packedFixed64_.WriteTo(output, TestPackedTypes._repeated_packedFixed64_codec)
      this.packedSfixed32_.WriteTo(output, TestPackedTypes._repeated_packedSfixed32_codec)
      this.packedSfixed64_.WriteTo(output, TestPackedTypes._repeated_packedSfixed64_codec)
      this.packedFloat_.WriteTo(output, TestPackedTypes._repeated_packedFloat_codec)
      this.packedDouble_.WriteTo(output, TestPackedTypes._repeated_packedDouble_codec)
      this.packedBool_.WriteTo(output, TestPackedTypes._repeated_packedBool_codec)
      this.packedEnum_.WriteTo(output, TestPackedTypes._repeated_packedEnum_codec)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      size <- size + this.packedInt32_.CalculateSize(TestPackedTypes._repeated_packedInt32_codec)
      size <- size + this.packedInt64_.CalculateSize(TestPackedTypes._repeated_packedInt64_codec)
      size <- size + this.packedUint32_.CalculateSize(TestPackedTypes._repeated_packedUint32_codec)
      size <- size + this.packedUint64_.CalculateSize(TestPackedTypes._repeated_packedUint64_codec)
      size <- size + this.packedSint32_.CalculateSize(TestPackedTypes._repeated_packedSint32_codec)
      size <- size + this.packedSint64_.CalculateSize(TestPackedTypes._repeated_packedSint64_codec)
      size <- size + this.packedFixed32_.CalculateSize(TestPackedTypes._repeated_packedFixed32_codec)
      size <- size + this.packedFixed64_.CalculateSize(TestPackedTypes._repeated_packedFixed64_codec)
      size <- size + this.packedSfixed32_.CalculateSize(TestPackedTypes._repeated_packedSfixed32_codec)
      size <- size + this.packedSfixed64_.CalculateSize(TestPackedTypes._repeated_packedSfixed64_codec)
      size <- size + this.packedFloat_.CalculateSize(TestPackedTypes._repeated_packedFloat_codec)
      size <- size + this.packedDouble_.CalculateSize(TestPackedTypes._repeated_packedDouble_codec)
      size <- size + this.packedBool_.CalculateSize(TestPackedTypes._repeated_packedBool_codec)
      size <- size + this.packedEnum_.CalculateSize(TestPackedTypes._repeated_packedEnum_codec)
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: TestPackedTypes) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        this.packedInt32_.Add(other.packedInt32_)
        this.packedInt64_.Add(other.packedInt64_)
        this.packedUint32_.Add(other.packedUint32_)
        this.packedUint64_.Add(other.packedUint64_)
        this.packedSint32_.Add(other.packedSint32_)
        this.packedSint64_.Add(other.packedSint64_)
        this.packedFixed32_.Add(other.packedFixed32_)
        this.packedFixed64_.Add(other.packedFixed64_)
        this.packedSfixed32_.Add(other.packedSfixed32_)
        this.packedSfixed64_.Add(other.packedSfixed64_)
        this.packedFloat_.Add(other.packedFloat_)
        this.packedDouble_.Add(other.packedDouble_)
        this.packedBool_.Add(other.packedBool_)
        this.packedEnum_.Add(other.packedEnum_)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 722u
          | 720u ->
            this.packedInt32_.AddEntriesFrom(input, TestPackedTypes._repeated_packedInt32_codec)
          | 730u
          | 728u ->
            this.packedInt64_.AddEntriesFrom(input, TestPackedTypes._repeated_packedInt64_codec)
          | 738u
          | 736u ->
            this.packedUint32_.AddEntriesFrom(input, TestPackedTypes._repeated_packedUint32_codec)
          | 746u
          | 744u ->
            this.packedUint64_.AddEntriesFrom(input, TestPackedTypes._repeated_packedUint64_codec)
          | 754u
          | 752u ->
            this.packedSint32_.AddEntriesFrom(input, TestPackedTypes._repeated_packedSint32_codec)
          | 762u
          | 760u ->
            this.packedSint64_.AddEntriesFrom(input, TestPackedTypes._repeated_packedSint64_codec)
          | 770u
          | 773u ->
            this.packedFixed32_.AddEntriesFrom(input, TestPackedTypes._repeated_packedFixed32_codec)
          | 778u
          | 777u ->
            this.packedFixed64_.AddEntriesFrom(input, TestPackedTypes._repeated_packedFixed64_codec)
          | 786u
          | 789u ->
            this.packedSfixed32_.AddEntriesFrom(input, TestPackedTypes._repeated_packedSfixed32_codec)
          | 794u
          | 793u ->
            this.packedSfixed64_.AddEntriesFrom(input, TestPackedTypes._repeated_packedSfixed64_codec)
          | 802u
          | 805u ->
            this.packedFloat_.AddEntriesFrom(input, TestPackedTypes._repeated_packedFloat_codec)
          | 810u
          | 809u ->
            this.packedDouble_.AddEntriesFrom(input, TestPackedTypes._repeated_packedDouble_codec)
          | 818u
          | 816u ->
            this.packedBool_.AddEntriesFrom(input, TestPackedTypes._repeated_packedBool_codec)
          | 826u
          | 824u ->
            this.packedEnum_.AddEntriesFrom(input, TestPackedTypes._repeated_packedEnum_codec)
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : TestPackedTypes =
      new TestPackedTypes(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: TestPackedTypes) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if not (this.packedInt32_.Equals(other.packedInt32_)) then false
      else if not (this.packedInt64_.Equals(other.packedInt64_)) then false
      else if not (this.packedUint32_.Equals(other.packedUint32_)) then false
      else if not (this.packedUint64_.Equals(other.packedUint64_)) then false
      else if not (this.packedSint32_.Equals(other.packedSint32_)) then false
      else if not (this.packedSint64_.Equals(other.packedSint64_)) then false
      else if not (this.packedFixed32_.Equals(other.packedFixed32_)) then false
      else if not (this.packedFixed64_.Equals(other.packedFixed64_)) then false
      else if not (this.packedSfixed32_.Equals(other.packedSfixed32_)) then false
      else if not (this.packedSfixed64_.Equals(other.packedSfixed64_)) then false
      else if not (this.packedFloat_.Equals(other.packedFloat_)) then false
      else if not (this.packedDouble_.Equals(other.packedDouble_)) then false
      else if not (this.packedBool_.Equals(other.packedBool_)) then false
      else if not (this.packedEnum_.Equals(other.packedEnum_)) then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = TestPackedTypes.Descriptor

/// <summary>
/// A message with the same fields as TestPackedTypes, but without packing. Used
/// to test packed &lt;-> unpacked wire compatibility.
/// </summary>
and [<AllowNullLiteral>] public TestUnpackedTypes =
  val mutable private unpackedInt32_ : RepeatedField<int>
  val mutable private unpackedInt64_ : RepeatedField<int64>
  val mutable private unpackedUint32_ : RepeatedField<uint32>
  val mutable private unpackedUint64_ : RepeatedField<uint64>
  val mutable private unpackedSint32_ : RepeatedField<int>
  val mutable private unpackedSint64_ : RepeatedField<int64>
  val mutable private unpackedFixed32_ : RepeatedField<uint32>
  val mutable private unpackedFixed64_ : RepeatedField<uint64>
  val mutable private unpackedSfixed32_ : RepeatedField<int>
  val mutable private unpackedSfixed64_ : RepeatedField<int64>
  val mutable private unpackedFloat_ : RepeatedField<single>
  val mutable private unpackedDouble_ : RepeatedField<double>
  val mutable private unpackedBool_ : RepeatedField<bool>
  val mutable private unpackedEnum_ : RepeatedField<ForeignEnum>

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      unpackedInt32_ = new RepeatedField<int>()
      unpackedInt64_ = new RepeatedField<int64>()
      unpackedUint32_ = new RepeatedField<uint32>()
      unpackedUint64_ = new RepeatedField<uint64>()
      unpackedSint32_ = new RepeatedField<int>()
      unpackedSint64_ = new RepeatedField<int64>()
      unpackedFixed32_ = new RepeatedField<uint32>()
      unpackedFixed64_ = new RepeatedField<uint64>()
      unpackedSfixed32_ = new RepeatedField<int>()
      unpackedSfixed64_ = new RepeatedField<int64>()
      unpackedFloat_ = new RepeatedField<single>()
      unpackedDouble_ = new RepeatedField<double>()
      unpackedBool_ = new RepeatedField<bool>()
      unpackedEnum_ = new RepeatedField<ForeignEnum>()
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: TestUnpackedTypes) =
    {
      unpackedInt32_ = other.unpackedInt32_.Clone()
      unpackedInt64_ = other.unpackedInt64_.Clone()
      unpackedUint32_ = other.unpackedUint32_.Clone()
      unpackedUint64_ = other.unpackedUint64_.Clone()
      unpackedSint32_ = other.unpackedSint32_.Clone()
      unpackedSint64_ = other.unpackedSint64_.Clone()
      unpackedFixed32_ = other.unpackedFixed32_.Clone()
      unpackedFixed64_ = other.unpackedFixed64_.Clone()
      unpackedSfixed32_ = other.unpackedSfixed32_.Clone()
      unpackedSfixed64_ = other.unpackedSfixed64_.Clone()
      unpackedFloat_ = other.unpackedFloat_.Clone()
      unpackedDouble_ = other.unpackedDouble_.Clone()
      unpackedBool_ = other.unpackedBool_.Clone()
      unpackedEnum_ = other.unpackedEnum_.Clone()
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<TestUnpackedTypes>(fun () -> new TestUnpackedTypes())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[25]

  /// <summary>Field number for the "unpacked_int32" field.</summary>
  static member public UnpackedInt32FieldNumber = 90
  static member private _repeated_unpackedInt32_codec =
    FieldCodec.ForInt32(720u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.UnpackedInt32
    with get() = this.unpackedInt32_

  /// <summary>Field number for the "unpacked_int64" field.</summary>
  static member public UnpackedInt64FieldNumber = 91
  static member private _repeated_unpackedInt64_codec =
    FieldCodec.ForInt64(728u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.UnpackedInt64
    with get() = this.unpackedInt64_

  /// <summary>Field number for the "unpacked_uint32" field.</summary>
  static member public UnpackedUint32FieldNumber = 92
  static member private _repeated_unpackedUint32_codec =
    FieldCodec.ForUInt32(736u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.UnpackedUint32
    with get() = this.unpackedUint32_

  /// <summary>Field number for the "unpacked_uint64" field.</summary>
  static member public UnpackedUint64FieldNumber = 93
  static member private _repeated_unpackedUint64_codec =
    FieldCodec.ForUInt64(744u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.UnpackedUint64
    with get() = this.unpackedUint64_

  /// <summary>Field number for the "unpacked_sint32" field.</summary>
  static member public UnpackedSint32FieldNumber = 94
  static member private _repeated_unpackedSint32_codec =
    FieldCodec.ForSInt32(752u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.UnpackedSint32
    with get() = this.unpackedSint32_

  /// <summary>Field number for the "unpacked_sint64" field.</summary>
  static member public UnpackedSint64FieldNumber = 95
  static member private _repeated_unpackedSint64_codec =
    FieldCodec.ForSInt64(760u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.UnpackedSint64
    with get() = this.unpackedSint64_

  /// <summary>Field number for the "unpacked_fixed32" field.</summary>
  static member public UnpackedFixed32FieldNumber = 96
  static member private _repeated_unpackedFixed32_codec =
    FieldCodec.ForFixed32(773u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.UnpackedFixed32
    with get() = this.unpackedFixed32_

  /// <summary>Field number for the "unpacked_fixed64" field.</summary>
  static member public UnpackedFixed64FieldNumber = 97
  static member private _repeated_unpackedFixed64_codec =
    FieldCodec.ForFixed64(777u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.UnpackedFixed64
    with get() = this.unpackedFixed64_

  /// <summary>Field number for the "unpacked_sfixed32" field.</summary>
  static member public UnpackedSfixed32FieldNumber = 98
  static member private _repeated_unpackedSfixed32_codec =
    FieldCodec.ForSFixed32(789u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.UnpackedSfixed32
    with get() = this.unpackedSfixed32_

  /// <summary>Field number for the "unpacked_sfixed64" field.</summary>
  static member public UnpackedSfixed64FieldNumber = 99
  static member private _repeated_unpackedSfixed64_codec =
    FieldCodec.ForSFixed64(793u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.UnpackedSfixed64
    with get() = this.unpackedSfixed64_

  /// <summary>Field number for the "unpacked_float" field.</summary>
  static member public UnpackedFloatFieldNumber = 100
  static member private _repeated_unpackedFloat_codec =
    FieldCodec.ForFloat(805u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.UnpackedFloat
    with get() = this.unpackedFloat_

  /// <summary>Field number for the "unpacked_double" field.</summary>
  static member public UnpackedDoubleFieldNumber = 101
  static member private _repeated_unpackedDouble_codec =
    FieldCodec.ForDouble(809u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.UnpackedDouble
    with get() = this.unpackedDouble_

  /// <summary>Field number for the "unpacked_bool" field.</summary>
  static member public UnpackedBoolFieldNumber = 102
  static member private _repeated_unpackedBool_codec =
    FieldCodec.ForBool(816u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.UnpackedBool
    with get() = this.unpackedBool_

  /// <summary>Field number for the "unpacked_enum" field.</summary>
  static member public UnpackedEnumFieldNumber = 103
  static member private _repeated_unpackedEnum_codec =
    FieldCodec.ForEnum(824u, (fun x -> int x), (fun x -> enum x))
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.UnpackedEnum
    with get() = this.unpackedEnum_

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? TestUnpackedTypes as x -> (x :> System.IEquatable<TestUnpackedTypes>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    hash <- hash ^^^ this.unpackedInt32_.GetHashCode()
    hash <- hash ^^^ this.unpackedInt64_.GetHashCode()
    hash <- hash ^^^ this.unpackedUint32_.GetHashCode()
    hash <- hash ^^^ this.unpackedUint64_.GetHashCode()
    hash <- hash ^^^ this.unpackedSint32_.GetHashCode()
    hash <- hash ^^^ this.unpackedSint64_.GetHashCode()
    hash <- hash ^^^ this.unpackedFixed32_.GetHashCode()
    hash <- hash ^^^ this.unpackedFixed64_.GetHashCode()
    hash <- hash ^^^ this.unpackedSfixed32_.GetHashCode()
    hash <- hash ^^^ this.unpackedSfixed64_.GetHashCode()
    hash <- hash ^^^ this.unpackedFloat_.GetHashCode()
    hash <- hash ^^^ this.unpackedDouble_.GetHashCode()
    hash <- hash ^^^ this.unpackedBool_.GetHashCode()
    hash <- hash ^^^ this.unpackedEnum_.GetHashCode()
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<TestUnpackedTypes> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      this.unpackedInt32_.WriteTo(output, TestUnpackedTypes._repeated_unpackedInt32_codec)
      this.unpackedInt64_.WriteTo(output, TestUnpackedTypes._repeated_unpackedInt64_codec)
      this.unpackedUint32_.WriteTo(output, TestUnpackedTypes._repeated_unpackedUint32_codec)
      this.unpackedUint64_.WriteTo(output, TestUnpackedTypes._repeated_unpackedUint64_codec)
      this.unpackedSint32_.WriteTo(output, TestUnpackedTypes._repeated_unpackedSint32_codec)
      this.unpackedSint64_.WriteTo(output, TestUnpackedTypes._repeated_unpackedSint64_codec)
      this.unpackedFixed32_.WriteTo(output, TestUnpackedTypes._repeated_unpackedFixed32_codec)
      this.unpackedFixed64_.WriteTo(output, TestUnpackedTypes._repeated_unpackedFixed64_codec)
      this.unpackedSfixed32_.WriteTo(output, TestUnpackedTypes._repeated_unpackedSfixed32_codec)
      this.unpackedSfixed64_.WriteTo(output, TestUnpackedTypes._repeated_unpackedSfixed64_codec)
      this.unpackedFloat_.WriteTo(output, TestUnpackedTypes._repeated_unpackedFloat_codec)
      this.unpackedDouble_.WriteTo(output, TestUnpackedTypes._repeated_unpackedDouble_codec)
      this.unpackedBool_.WriteTo(output, TestUnpackedTypes._repeated_unpackedBool_codec)
      this.unpackedEnum_.WriteTo(output, TestUnpackedTypes._repeated_unpackedEnum_codec)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      size <- size + this.unpackedInt32_.CalculateSize(TestUnpackedTypes._repeated_unpackedInt32_codec)
      size <- size + this.unpackedInt64_.CalculateSize(TestUnpackedTypes._repeated_unpackedInt64_codec)
      size <- size + this.unpackedUint32_.CalculateSize(TestUnpackedTypes._repeated_unpackedUint32_codec)
      size <- size + this.unpackedUint64_.CalculateSize(TestUnpackedTypes._repeated_unpackedUint64_codec)
      size <- size + this.unpackedSint32_.CalculateSize(TestUnpackedTypes._repeated_unpackedSint32_codec)
      size <- size + this.unpackedSint64_.CalculateSize(TestUnpackedTypes._repeated_unpackedSint64_codec)
      size <- size + this.unpackedFixed32_.CalculateSize(TestUnpackedTypes._repeated_unpackedFixed32_codec)
      size <- size + this.unpackedFixed64_.CalculateSize(TestUnpackedTypes._repeated_unpackedFixed64_codec)
      size <- size + this.unpackedSfixed32_.CalculateSize(TestUnpackedTypes._repeated_unpackedSfixed32_codec)
      size <- size + this.unpackedSfixed64_.CalculateSize(TestUnpackedTypes._repeated_unpackedSfixed64_codec)
      size <- size + this.unpackedFloat_.CalculateSize(TestUnpackedTypes._repeated_unpackedFloat_codec)
      size <- size + this.unpackedDouble_.CalculateSize(TestUnpackedTypes._repeated_unpackedDouble_codec)
      size <- size + this.unpackedBool_.CalculateSize(TestUnpackedTypes._repeated_unpackedBool_codec)
      size <- size + this.unpackedEnum_.CalculateSize(TestUnpackedTypes._repeated_unpackedEnum_codec)
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: TestUnpackedTypes) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        this.unpackedInt32_.Add(other.unpackedInt32_)
        this.unpackedInt64_.Add(other.unpackedInt64_)
        this.unpackedUint32_.Add(other.unpackedUint32_)
        this.unpackedUint64_.Add(other.unpackedUint64_)
        this.unpackedSint32_.Add(other.unpackedSint32_)
        this.unpackedSint64_.Add(other.unpackedSint64_)
        this.unpackedFixed32_.Add(other.unpackedFixed32_)
        this.unpackedFixed64_.Add(other.unpackedFixed64_)
        this.unpackedSfixed32_.Add(other.unpackedSfixed32_)
        this.unpackedSfixed64_.Add(other.unpackedSfixed64_)
        this.unpackedFloat_.Add(other.unpackedFloat_)
        this.unpackedDouble_.Add(other.unpackedDouble_)
        this.unpackedBool_.Add(other.unpackedBool_)
        this.unpackedEnum_.Add(other.unpackedEnum_)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 722u
          | 720u ->
            this.unpackedInt32_.AddEntriesFrom(input, TestUnpackedTypes._repeated_unpackedInt32_codec)
          | 730u
          | 728u ->
            this.unpackedInt64_.AddEntriesFrom(input, TestUnpackedTypes._repeated_unpackedInt64_codec)
          | 738u
          | 736u ->
            this.unpackedUint32_.AddEntriesFrom(input, TestUnpackedTypes._repeated_unpackedUint32_codec)
          | 746u
          | 744u ->
            this.unpackedUint64_.AddEntriesFrom(input, TestUnpackedTypes._repeated_unpackedUint64_codec)
          | 754u
          | 752u ->
            this.unpackedSint32_.AddEntriesFrom(input, TestUnpackedTypes._repeated_unpackedSint32_codec)
          | 762u
          | 760u ->
            this.unpackedSint64_.AddEntriesFrom(input, TestUnpackedTypes._repeated_unpackedSint64_codec)
          | 770u
          | 773u ->
            this.unpackedFixed32_.AddEntriesFrom(input, TestUnpackedTypes._repeated_unpackedFixed32_codec)
          | 778u
          | 777u ->
            this.unpackedFixed64_.AddEntriesFrom(input, TestUnpackedTypes._repeated_unpackedFixed64_codec)
          | 786u
          | 789u ->
            this.unpackedSfixed32_.AddEntriesFrom(input, TestUnpackedTypes._repeated_unpackedSfixed32_codec)
          | 794u
          | 793u ->
            this.unpackedSfixed64_.AddEntriesFrom(input, TestUnpackedTypes._repeated_unpackedSfixed64_codec)
          | 802u
          | 805u ->
            this.unpackedFloat_.AddEntriesFrom(input, TestUnpackedTypes._repeated_unpackedFloat_codec)
          | 810u
          | 809u ->
            this.unpackedDouble_.AddEntriesFrom(input, TestUnpackedTypes._repeated_unpackedDouble_codec)
          | 818u
          | 816u ->
            this.unpackedBool_.AddEntriesFrom(input, TestUnpackedTypes._repeated_unpackedBool_codec)
          | 826u
          | 824u ->
            this.unpackedEnum_.AddEntriesFrom(input, TestUnpackedTypes._repeated_unpackedEnum_codec)
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : TestUnpackedTypes =
      new TestUnpackedTypes(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: TestUnpackedTypes) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if not (this.unpackedInt32_.Equals(other.unpackedInt32_)) then false
      else if not (this.unpackedInt64_.Equals(other.unpackedInt64_)) then false
      else if not (this.unpackedUint32_.Equals(other.unpackedUint32_)) then false
      else if not (this.unpackedUint64_.Equals(other.unpackedUint64_)) then false
      else if not (this.unpackedSint32_.Equals(other.unpackedSint32_)) then false
      else if not (this.unpackedSint64_.Equals(other.unpackedSint64_)) then false
      else if not (this.unpackedFixed32_.Equals(other.unpackedFixed32_)) then false
      else if not (this.unpackedFixed64_.Equals(other.unpackedFixed64_)) then false
      else if not (this.unpackedSfixed32_.Equals(other.unpackedSfixed32_)) then false
      else if not (this.unpackedSfixed64_.Equals(other.unpackedSfixed64_)) then false
      else if not (this.unpackedFloat_.Equals(other.unpackedFloat_)) then false
      else if not (this.unpackedDouble_.Equals(other.unpackedDouble_)) then false
      else if not (this.unpackedBool_.Equals(other.unpackedBool_)) then false
      else if not (this.unpackedEnum_.Equals(other.unpackedEnum_)) then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = TestUnpackedTypes.Descriptor

and [<AllowNullLiteral>] public TestRepeatedScalarDifferentTagSizes =
  val mutable private repeatedFixed32_ : RepeatedField<uint32>
  val mutable private repeatedInt32_ : RepeatedField<int>
  val mutable private repeatedFixed64_ : RepeatedField<uint64>
  val mutable private repeatedInt64_ : RepeatedField<int64>
  val mutable private repeatedFloat_ : RepeatedField<single>
  val mutable private repeatedUint64_ : RepeatedField<uint64>

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      repeatedFixed32_ = new RepeatedField<uint32>()
      repeatedInt32_ = new RepeatedField<int>()
      repeatedFixed64_ = new RepeatedField<uint64>()
      repeatedInt64_ = new RepeatedField<int64>()
      repeatedFloat_ = new RepeatedField<single>()
      repeatedUint64_ = new RepeatedField<uint64>()
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: TestRepeatedScalarDifferentTagSizes) =
    {
      repeatedFixed32_ = other.repeatedFixed32_.Clone()
      repeatedInt32_ = other.repeatedInt32_.Clone()
      repeatedFixed64_ = other.repeatedFixed64_.Clone()
      repeatedInt64_ = other.repeatedInt64_.Clone()
      repeatedFloat_ = other.repeatedFloat_.Clone()
      repeatedUint64_ = other.repeatedUint64_.Clone()
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<TestRepeatedScalarDifferentTagSizes>(fun () -> new TestRepeatedScalarDifferentTagSizes())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[26]

  /// <summary>Field number for the "repeated_fixed32" field.</summary>
  static member public RepeatedFixed32FieldNumber = 12
  static member private _repeated_repeatedFixed32_codec =
    FieldCodec.ForFixed32(98u)
  /// <summary>
  /// Parsing repeated fixed size values used to fail. This message needs to be
  /// used in order to get a tag of the right size; all of the repeated fields
  /// in TestAllTypes didn't trigger the check.
  /// </summary>
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedFixed32
    with get() = this.repeatedFixed32_

  /// <summary>Field number for the "repeated_int32" field.</summary>
  static member public RepeatedInt32FieldNumber = 13
  static member private _repeated_repeatedInt32_codec =
    FieldCodec.ForInt32(106u)
  /// <summary>
  /// Check for a varint type, just for good measure.
  /// </summary>
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedInt32
    with get() = this.repeatedInt32_

  /// <summary>Field number for the "repeated_fixed64" field.</summary>
  static member public RepeatedFixed64FieldNumber = 2046
  static member private _repeated_repeatedFixed64_codec =
    FieldCodec.ForFixed64(16370u)
  /// <summary>
  /// These have two-byte tags.
  /// </summary>
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedFixed64
    with get() = this.repeatedFixed64_

  /// <summary>Field number for the "repeated_int64" field.</summary>
  static member public RepeatedInt64FieldNumber = 2047
  static member private _repeated_repeatedInt64_codec =
    FieldCodec.ForInt64(16378u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedInt64
    with get() = this.repeatedInt64_

  /// <summary>Field number for the "repeated_float" field.</summary>
  static member public RepeatedFloatFieldNumber = 262142
  static member private _repeated_repeatedFloat_codec =
    FieldCodec.ForFloat(2097138u)
  /// <summary>
  /// Three byte tags.
  /// </summary>
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedFloat
    with get() = this.repeatedFloat_

  /// <summary>Field number for the "repeated_uint64" field.</summary>
  static member public RepeatedUint64FieldNumber = 262143
  static member private _repeated_repeatedUint64_codec =
    FieldCodec.ForUInt64(2097146u)
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.RepeatedUint64
    with get() = this.repeatedUint64_

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? TestRepeatedScalarDifferentTagSizes as x -> (x :> System.IEquatable<TestRepeatedScalarDifferentTagSizes>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    hash <- hash ^^^ this.repeatedFixed32_.GetHashCode()
    hash <- hash ^^^ this.repeatedInt32_.GetHashCode()
    hash <- hash ^^^ this.repeatedFixed64_.GetHashCode()
    hash <- hash ^^^ this.repeatedInt64_.GetHashCode()
    hash <- hash ^^^ this.repeatedFloat_.GetHashCode()
    hash <- hash ^^^ this.repeatedUint64_.GetHashCode()
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<TestRepeatedScalarDifferentTagSizes> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      this.repeatedFixed32_.WriteTo(output, TestRepeatedScalarDifferentTagSizes._repeated_repeatedFixed32_codec)
      this.repeatedInt32_.WriteTo(output, TestRepeatedScalarDifferentTagSizes._repeated_repeatedInt32_codec)
      this.repeatedFixed64_.WriteTo(output, TestRepeatedScalarDifferentTagSizes._repeated_repeatedFixed64_codec)
      this.repeatedInt64_.WriteTo(output, TestRepeatedScalarDifferentTagSizes._repeated_repeatedInt64_codec)
      this.repeatedFloat_.WriteTo(output, TestRepeatedScalarDifferentTagSizes._repeated_repeatedFloat_codec)
      this.repeatedUint64_.WriteTo(output, TestRepeatedScalarDifferentTagSizes._repeated_repeatedUint64_codec)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      size <- size + this.repeatedFixed32_.CalculateSize(TestRepeatedScalarDifferentTagSizes._repeated_repeatedFixed32_codec)
      size <- size + this.repeatedInt32_.CalculateSize(TestRepeatedScalarDifferentTagSizes._repeated_repeatedInt32_codec)
      size <- size + this.repeatedFixed64_.CalculateSize(TestRepeatedScalarDifferentTagSizes._repeated_repeatedFixed64_codec)
      size <- size + this.repeatedInt64_.CalculateSize(TestRepeatedScalarDifferentTagSizes._repeated_repeatedInt64_codec)
      size <- size + this.repeatedFloat_.CalculateSize(TestRepeatedScalarDifferentTagSizes._repeated_repeatedFloat_codec)
      size <- size + this.repeatedUint64_.CalculateSize(TestRepeatedScalarDifferentTagSizes._repeated_repeatedUint64_codec)
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: TestRepeatedScalarDifferentTagSizes) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        this.repeatedFixed32_.Add(other.repeatedFixed32_)
        this.repeatedInt32_.Add(other.repeatedInt32_)
        this.repeatedFixed64_.Add(other.repeatedFixed64_)
        this.repeatedInt64_.Add(other.repeatedInt64_)
        this.repeatedFloat_.Add(other.repeatedFloat_)
        this.repeatedUint64_.Add(other.repeatedUint64_)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 98u
          | 101u ->
            this.repeatedFixed32_.AddEntriesFrom(input, TestRepeatedScalarDifferentTagSizes._repeated_repeatedFixed32_codec)
          | 106u
          | 104u ->
            this.repeatedInt32_.AddEntriesFrom(input, TestRepeatedScalarDifferentTagSizes._repeated_repeatedInt32_codec)
          | 16370u
          | 16369u ->
            this.repeatedFixed64_.AddEntriesFrom(input, TestRepeatedScalarDifferentTagSizes._repeated_repeatedFixed64_codec)
          | 16378u
          | 16376u ->
            this.repeatedInt64_.AddEntriesFrom(input, TestRepeatedScalarDifferentTagSizes._repeated_repeatedInt64_codec)
          | 2097138u
          | 2097141u ->
            this.repeatedFloat_.AddEntriesFrom(input, TestRepeatedScalarDifferentTagSizes._repeated_repeatedFloat_codec)
          | 2097146u
          | 2097144u ->
            this.repeatedUint64_.AddEntriesFrom(input, TestRepeatedScalarDifferentTagSizes._repeated_repeatedUint64_codec)
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : TestRepeatedScalarDifferentTagSizes =
      new TestRepeatedScalarDifferentTagSizes(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: TestRepeatedScalarDifferentTagSizes) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if not (this.repeatedFixed32_.Equals(other.repeatedFixed32_)) then false
      else if not (this.repeatedInt32_.Equals(other.repeatedInt32_)) then false
      else if not (this.repeatedFixed64_.Equals(other.repeatedFixed64_)) then false
      else if not (this.repeatedInt64_.Equals(other.repeatedInt64_)) then false
      else if not (this.repeatedFloat_.Equals(other.repeatedFloat_)) then false
      else if not (this.repeatedUint64_.Equals(other.repeatedUint64_)) then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = TestRepeatedScalarDifferentTagSizes.Descriptor

and [<AllowNullLiteral>] public TestCommentInjectionMessage =
  val mutable private a_ : string

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
      a_ = ""
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: TestCommentInjectionMessage) =
    {
      a_ = other.a_
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<TestCommentInjectionMessage>(fun () -> new TestCommentInjectionMessage())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[27]

  /// <summary>Field number for the "a" field.</summary>
  static member public AFieldNumber = 1
  /// <summary>
  /// */ &lt;- This should not close the generated doc comment
  /// </summary>
  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  member public this.A
    with get() = this.a_
    and set(value: string) =
      if value <> null then
        this.a_ <- value


  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? TestCommentInjectionMessage as x -> (x :> System.IEquatable<TestCommentInjectionMessage>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    if this.A.Length <> 0 then hash <- hash ^^^ this.A.GetHashCode()
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<TestCommentInjectionMessage> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      if this.A.Length <> 0 then
        output.WriteRawTag(10uy)
        output.WriteString(this.A)


    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      if this.A.Length <> 0 then
        size <- size + 1 + CodedOutputStream.ComputeStringSize(this.A)
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: TestCommentInjectionMessage) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        if other.A.Length <> 0 then
          this.A <- other.A

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | 10u ->
            this.A <- input.ReadString()
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : TestCommentInjectionMessage =
      new TestCommentInjectionMessage(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: TestCommentInjectionMessage) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else if this.A <> other.A then false
      else true

    member this.Descriptor : Reflection.MessageDescriptor = TestCommentInjectionMessage.Descriptor

/// <summary>
/// Test that RPC services work.
/// </summary>
and [<AllowNullLiteral>] public FooRequest =

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: FooRequest) =
    {
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<FooRequest>(fun () -> new FooRequest())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[28]

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? FooRequest as x -> (x :> System.IEquatable<FooRequest>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<FooRequest> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      ()
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: FooRequest) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        ()
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : FooRequest =
      new FooRequest(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: FooRequest) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else true

    member this.Descriptor : Reflection.MessageDescriptor = FooRequest.Descriptor

and [<AllowNullLiteral>] public FooResponse =

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: FooResponse) =
    {
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<FooResponse>(fun () -> new FooResponse())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[29]

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? FooResponse as x -> (x :> System.IEquatable<FooResponse>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<FooResponse> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      ()
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: FooResponse) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        ()
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : FooResponse =
      new FooResponse(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: FooResponse) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else true

    member this.Descriptor : Reflection.MessageDescriptor = FooResponse.Descriptor

and [<AllowNullLiteral>] public FooClientMessage =

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: FooClientMessage) =
    {
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<FooClientMessage>(fun () -> new FooClientMessage())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[30]

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? FooClientMessage as x -> (x :> System.IEquatable<FooClientMessage>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<FooClientMessage> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      ()
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: FooClientMessage) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        ()
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : FooClientMessage =
      new FooClientMessage(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: FooClientMessage) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else true

    member this.Descriptor : Reflection.MessageDescriptor = FooClientMessage.Descriptor

and [<AllowNullLiteral>] public FooServerMessage =

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: FooServerMessage) =
    {
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<FooServerMessage>(fun () -> new FooServerMessage())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[31]

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? FooServerMessage as x -> (x :> System.IEquatable<FooServerMessage>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<FooServerMessage> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      ()
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: FooServerMessage) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        ()
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : FooServerMessage =
      new FooServerMessage(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: FooServerMessage) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else true

    member this.Descriptor : Reflection.MessageDescriptor = FooServerMessage.Descriptor

and [<AllowNullLiteral>] public BarRequest =

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: BarRequest) =
    {
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<BarRequest>(fun () -> new BarRequest())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[32]

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? BarRequest as x -> (x :> System.IEquatable<BarRequest>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<BarRequest> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      ()
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: BarRequest) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        ()
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : BarRequest =
      new BarRequest(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: BarRequest) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else true

    member this.Descriptor : Reflection.MessageDescriptor = BarRequest.Descriptor

and [<AllowNullLiteral>] public BarResponse =

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new () =
    {
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  new (other: BarResponse) =
    {
    }

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Parser = new MessageParser<BarResponse>(fun () -> new BarResponse())

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  static member Descriptor = UnittestProto3Reflection.Descriptor.MessageTypes.[33]

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.Equals(other: System.Object) : bool =
    match other with
      | :? BarResponse as x -> (x :> System.IEquatable<BarResponse>).Equals(this)
      | _ -> false

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.GetHashCode() : int =
    let mutable hash = 1
    hash

  [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
  override this.ToString() =
    JsonFormatter.ToDiagnosticString(this)

  interface IMessage<BarResponse> with
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.WriteTo(output: CodedOutputStream) : unit =
      ()
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.CalculateSize() : int =
      let mutable size = 0
      size

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(other: BarResponse) : unit =
      if not (System.Object.ReferenceEquals(other, null)) then
        ()
    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.MergeFrom(input: CodedInputStream) : unit =
      let mutable tag = input.ReadTag()
      while (tag <> 0u) do
        match tag with
          | _ ->
            input.SkipLastField()
        tag <- input.ReadTag()

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Clone() : BarResponse =
      new BarResponse(this)

    [<System.Diagnostics.DebuggerNonUserCodeAttribute>]
    member this.Equals(other: BarResponse) : bool =
      if System.Object.ReferenceEquals(other, null) then
        false
      else if System.Object.ReferenceEquals(other, this) then
        true
      else true

    member this.Descriptor : Reflection.MessageDescriptor = BarResponse.Descriptor


